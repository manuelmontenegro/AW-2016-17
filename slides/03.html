<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tema 3 - Javascript</title>


    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/aw.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/magula.css">


    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <link rel="stylesheet" href="css/traspas.css" />
</head>

<body>
    <svg width="0" height="0" style="float:left">
        <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto" markerUnits="strokeWidth" style="display:float">
                <path d="M0,0 L0,6 L9,3 z" fill="#000" />
            </marker>
        </defs>
    </svg>
    <div class="reveal">
        <div class="slides">
            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade">
                <div class="headerlesson">Tema 3</div>
                <h1 style="height:3em;position:relative;top:0.3em">Programación en JavascriPT</h1>
                <div class="headerlesson">
                    Aplicaciones Web - GIS - Curso 2016/17
                </div>
                <div class="author">
                    <span class="myname">Manuel Montenegro</span> [<a href="mailto:montenegro@fdi.ucm.es" style="color:white">montenegro@fdi.ucm.es</a>]
                    <br/> Dpto de Sistemas Informáticos y Computación
                    <br/> Facultad de Informática
                    <br/> Universidad Complutense de Madrid
                </div>
                <div class="cc">
                    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                    <br/> Esta obra está bajo una
                    <br/><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:white">Licencia CC BY-NC-SA 4.0 Internacional</a>.
                </div>
                <div style="clear:left;font-size:15px"></div>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade" id="p1">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline fragment highlight-orange">Primeros programas</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p6" class="outline">ECMAscript 6</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p2">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Primeros programas</a></li>
                    <li><a href="#/p2" class="outline current">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p6" class="outline">ECMAscript 6</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>
            

            <section>
                <h2>El &laquo;Java&raquo; en Javascript</h2>
                <p>
                    La sintaxis de Javascript está inspirada, en gran medida, por la de Java.
                </p>
                <ul>
                    <li>
                        Comentarios:
                        <pre><code data-trim class="javascript">
// Comentario de una línea
/* Comentario de varias
   líneas */
                        </code></pre>
                    </li>
                    <li>Declaraciones de variables y asignaciones:
                    <pre><code data-trim class="javascript">
var x = 3;
var y = y + 1;
y += 3;
                    </code></pre>
                    </li>
                    <li>Pre/postincremento, pre/postdecremento:
                    <pre><code data-trim class="javascript">
z = x++;
--x;
                    </code></pre>
                    </li>
                    
                </ul>
            </section>
            
            <section>
                <h3>Sentencias condicionales</h3>
                <ul style="width:20em">
                    <li>
                        If-then-else:
                        <pre><code data-trim class="javascript">
if (x &lt; y) {
    return x;
} else {
    return y;
}                         
                        </code></pre>
                    </li>
                    <li>
                        Switch:
                        <pre><code data-trim class="javascript">
switch(day) {
    case 6:
    case 7:
        console.log("Es fin de semana");
        break;
    default:
        console.log("Es día laborable");
}
                        </code></pre>
                    </li>
                </ul>
            </section>
            
            <section>
                <h3>Bucles</h3>
                <ul style="width:20em">
                    <li>Bucle while
                    <pre><code data-trim class="javascript">
while (x &lt;= 0) {
    n = n * x;
    x--;
}
                    </code></pre>
                    </li>
                    <li>Bucle do-while:
                    <pre><code data-trim class="javascript">
do {
    mult *= a[x];
    x++:
} while (a[x] === 0)
                    </code></pre>
                    </li>
                    <li>
                        Bucles for:
                        <pre><code data-trim class="javascript">
for (var i = 0; i &lt; b.length; i++) {
    sum += b[i] + c[i];
}
                        </code></pre>
                    </li>
                </ul>
            </section>
            
            <section>
                <ul style="width:20em">
                    <li>
                        break y continue:
                        <pre><code data-trim class="javascript">
for (var i = 0; i &lt; x.length; i++) {
    if (x[i] % 2 === 0)
        continue;
    z *= x[i];
}
                        </code></pre>
                        <pre><code data-trim class="javascript">
while (i &lt; x.length) {
    if (x[i] === ".") break;
    i++;
}
                        
                        </code></pre>
                    </li>
                </ul>
            </section>
            
            <section>
                <h3>Funciones</h3>
                <pre><code data-trim class="javascript">
function abs(x) {
    if (x &lt; 0) {
        return x;
    } else {
        return -x;
    }
}
                </code></pre>
                <ul style="width: 100%">
                    <li>
                        Llamadas a funciones y métodos:
                    </li>
                </ul>
<pre><code data-trim class="javascript">
x = abs(-3);
console.log("El valor absoluto de x es " + x);
</code></pre>                        
            </section>
            
            <section>
                <h3>Manejo de excepciones</h3>
                <ul style="width:100%">
                    <li>
                        Bloques try-catch-finally:
                        <pre><code data-trim data-noescape class="javascript">
try {
   funcion_no_existe();
} catch (e) {  <span class="arrow_box_left caja_codigo fragment" style="position:relative;left:5em">No se especifica el tipo de excepción</span>
    console.error(e.message);
} finally {
    console.log("Esto se ejecuta siempre");
}
                        </code></pre>
                    </li>
                    <li>
                        Lanzamiento de excepciones:
                        <pre><code data-trim class="javascript">
throw new Error("Fichero no encontrado");
                        </code></pre>
                    </li>
                    <li>
                    Atributos de <code>Error</code>:
                        <ul>
                            <li><code>Error.message</code>: mensaje de error.</li>
                            <li><code>Error.stack</code>: pila de ejecución.</li>
                            <li><code>Error.name</code>: nombre de la clase del error.</li>
                        </ul>
                    </li>
                </ul>
            </section>
            
            <section>
                <h3>Cadenas de texto</h3>
                <ul style="float:left; width:45%">
                    <li>Inicialización:
                    <pre><code data-trim class="javascript">
var str = "Esto es una cadena";
                    </code></pre>
                        o bien
                    <pre><code data-trim class="javascript">
var str = 'Esto es una cadena';
                    </code></pre>
                    </li>
                    <li>
                        Acceso al carácter i-ésimo:
                        <pre><code data-trim data-noescape class="javascript">
str[2]  <span class="no_arrow_box caja_codigo fragment">!</span> // &rarr; "t" 
                        </code></pre>
                    </li>
                </ul>
                <ul style="float:right; width:45%">
                    <li>Métodos:
                    <pre><code data-trim class="javascript">
str.slice(2, 5); 
    // &rarr; "to es"
"  vale ".trim();
    // &rarr; "vale"
str.split(" ");
    // &rarr; ["Esto", "es", 
    //    "una", "cadena"]
str.toUpperCase();
    // &rarr; "ESTO ES UNA CADENA"
str.toLocaleUpperCase();
    // &rarr; "ESTO ES UNA CADENA"
str.startsWith("Est");
    // &rarr; true
"ab".repeat(5);
    // &rarr; "ababababab"
                    </code></pre>
                    </li>
                </ul>
                <div style="clear:both"></div>
            </section>
            
            <section>
                <h3>Operadores</h3>
                <ul style="position:relative; top: 1em">
                    <li>Relacionales:
                        <code>==</code>, <code>===</code>, 
                        <code>&lt;</code>, <code>&lt;=</code>,
                        <code>&gt;</code>, <code>&gt;=</code>
                                                <span class="no_arrow_box caja_codigo fragment"
                              style="position:relative; top:-1.3em;left:-6.4em"
                              >!</span>

                    </li>
                    
                    <li>
                        Aritméticos:
                        <code>+</code>, <code>-</code>, <code>*</code>,
                        <code>/</code>, <code>%</code>
                    </li>
                    
                    <li>
                        Lógicos:
                        <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>
                    </li>
                    <li>
                        A nivel de bit:
                        <code>&amp;</code>, <code>|</code>, <code>^</code>,
                        <code>&gt;&gt;</code>, <code>&lt;&lt;</code>,
                        <code>&lt;&lt;&lt;</code>
                    </li>
                    
                </ul>
            </section>
            
            
            <section>
                <h3>Arrays</h3>
                <ul style="width:100%">
                    <li>Inicialización:
                    <pre><code data-trim data-noescape class="javascript">
var x = [4, 6, "pepe", 1, 3]; <span class="arrow_box_left caja_codigo fragment">Corchetes en lugar de { }</span>

var z = []; <span class="arrow_box_left caja_codigo fragment" style="position:relative;">Vector vacío</span>

var m = new Array(3);
                    </code></pre>
                    </li>
                    <li>Acceso:
                        <pre><code data-trim class="javascript">
console.log(x[3]);  // &rarr; 1
m[2] = "Elemento nuevo";
                        </code></pre>
                    </li>
                    <li>
                        Longitud:
                        <pre><code data-trim class="javascript">
x.length  // &rarr; 5
z.length  // &rarr; 0
m.length  // &rarr; 3
                        </code></pre>
                    </li>
                </ul>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p3">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Primeros programas</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline current">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p6" class="outline">ECMAscript 6</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>
            
            <section>
                <h2>Las 10 rarezas de Javascript</h2>
                <p><strong>(según un programador/a Java)</strong></p>
                <ol>
                    <li>Javascript es dinámicamente tipado.</li>
                    <li>Valores indefinidos, nulos y NaN.</li>
                    <li>Las conversiones invisibles.</li>
                    <li>Argumentos que sobran y faltan.</li>
                    <li>Las funciones son ciudadanos de primera clase.</li>
                </ol>
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 1</span><span style="display:none">:</span><br>Javascript es un lenguaje dinámicamente tipado</h3>
                    </div>
                </section>
                
                <section>
                    <h3>declaraciones de tipo</h3>
                    <p>En Java es necesario declarar el tipo de una variable antes de su primer uso:</p>
                    <pre><code data-trim class="java">
int x;
String z = "It's something";
List&lt;Integer&gt; lista;
                    </code></pre>
                    
                    <p>En Javascript no se indica el tipo de la variable a declarar. Se utiliza siempre la palabra reservada <code>var</code>.</p>
                    <pre><code data-trim class="javascript">
var x;
var z = "It's something";
var lista;
                    </code></pre>
                    
                    <div class="fragment" style="color:blue">
                        ¿Qué ventajas e inconvenientes tiene indicar el tipo de las variables en el programa?
                    </div>
                </section>
                
                <section>
                    <h4>Lenguajes <strong>estáticamente tipados</strong></h4>
                    <ul>
                        <li>
                            <p>El compilador detecta <strong>en tiempo de compilación</strong> que las operaciones se realizan sobre argumentos del tipo correcto.</p>
                            <p>Por ejemplo, el compilador avisa de cosas como:</p>
                            <pre><code data-trim class="javascript">
"pepe" * 24                            
                            </code></pre>
                        </li>
                        <li>
                            <p>Pueden requerir declaraciones de tipos por parte del programador.</p>
                            <p>Por ejemplo: Java, C, etc.</p>
                        </li>
                        <li>
                            <p>En algunos casos <strong>infieren</strong> información de tipos</p>
                            <p>Por ejemplo: Haskell, C++, etc.</p>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <h4>Lenguajes <strong>dinámicamente</strong> tipados</h4>
                    <ul>
                        <li>
                            <p>Se comprueba <strong>durante la ejecución del programa</strong> que las operaciones se realizan sobre argumentos de tipo correcto.</p>
                            <p>Por ejemplo, en Javascript:</p>
                            <pre><code data-trim class="javascript">
if (...) {
    y = 3 * "foo";
}
                            </code></pre>
                            <p>El error debido a la expresión <code>3 * "foo"</code> solamente se manifestará si la condición del <code>if</code> se cumple.</p>
                        </li>
                        
                    </ul>
                </section>
                <section>
                    <h4>Ejemplos</h4>
                    <ul>
                        <li><p><strong>Lenguajes sin tipos</strong></p>
                            <p style="font-size:70%">Son poco usuales: Tcl, ensamblador, etc.</p>
                        </li>
                        <li>
                            <p><strong>Lenguajes estáticamente tipados, no dinámicamente</strong></p>
                            <p style="font-size:70%">C, Haskell, etc.</p>
                        </li>
                        <li>
                            <p><strong>Lenguajes dinámicamente tipados, no estáticamente</strong></p>
                            <p style="font-size:70%">Python, Javascript, PHP, etc.</p>
                        </li>
                        <li>
                            <p><strong>Lenguajes estáticamente y dinámicamente tipados</strong></p>
                            <p style="font-size:70%">Java, C++, C#, etc.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <h4>Tipos disponibles en Javascript</h4>
                    <ul>
                        <li>Tipo del valor indefinido (<code>undefined</code>)</li>
                        <li>Tipo del puntero nulo (<code>null</code>)</li>
                        <li><p>Tipo numérico (<code>number</code>).</p><p style="font-size:70%">El sistema de tipos no distingue entre enteros y coma flotante.</p></li>
                        <li>Tipo booleano (<code>boolean</code>).<p  style="font-size:70%">Incluye los valores <code>true</code> y <code>false</code>.</p></li>
                        <li>Tipo cadena (<code>string</code>).</li>
                        <li>Tipo objeto (<code>object</code>).
                            <p style="font-size:70%">Incluye también a arrays, funciones y expresiones regulares.</p>
                        </li>
                        
                    </ul>
                </section>
                
                <section>
                    <h4>Tipos primitivos vs tipos objeto</h4>
                    <div style="width:80%;margin-left:auto;margin-right:auto">
                    <ul style="float:left">
                        <li>Tipos primitivos:
                            <ul>
                                <li>Indefinido</li>
                                <li>Nulo</li>
                                <li>Numérico</li>
                                <li>Booleano</li>
                                <li>Cadena</li>
                            </ul>
                        </li>
                    </ul>
                    <ul>
                        <li>Tipos objeto:
                            <ul><li>Objeto</li></ul>
                        </li>
                    </ul>
                    </div>
                    <div style="clear:both"></div>
                </section>                
                <section>
                    <p>Los tipos primitivos son <strong>inmutables</strong></p>
                    <pre><code data-trim data-noescape class="javascript">
var str1 = "Cadena";
var str2 = str1.slice(0, 3);      <span class="arrow_box_left caja_codigo">No modifica la cadena <span style="font-family:monospace">str1</span></span>
console.log(str1);  // &rarr; Cadena1
console.log(str2);  // &rarr; Cad
                    </code></pre>
                    <p>Las comparaciones entre tipos primitivos se hacen por <strong>valor</strong>, no por referencia</p>
                    <pre><code data-trim data-noescape class="javascript">
var str1 = "Cadena";
var str2 = "Cadena";
var str3 = "Otra cadena";
str1 == str2;   // &rarr; true
str1 === str2;  // &rarr; true
str1 != str3    // &rarr; true
str1 !== str3   // &rarr; true
                    </code></pre>
                    <p>En Java <code>str1 == str2</code> devuelve <code>false</code>, pues son
                    objetos distintos. En cambio, <code>str1.equals(str2)</code> devuelve <code>true</code>.</p>
                </section>
                
                <section>
                    <p>Las cadenas pueden compararse lexicográficamente mediante los operadores
                    relacionales <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code> y
                    <code>&gt;</code>:</p>
                    <pre><code data-trim class="javascript">
"Pablo" &lt; "Diana"    // &rarr; true
"Pablo" &lt; "Paolo"    // &rarr; true 
"alma" &lt;= "Pablo"    // &rarr; false
"Águeda" &lt; "Pablo"   // &rarr; false
                    </code></pre>
                    <p>Se utiliza <code>localeCompare()</code> para comparar según el abecedario del idioma correspondiente.</p>
                    <pre><code data-trim class="javascript">
"alma".localeCompare("Pablo");      // &rarr; -1 ('alma' es menor)
"Sergio".localeCompare("Pablo");    // &rarr; 1  ('Pablo' es menor)
"Sergio".localeCompare("Sergio");   // &rarr; 0  (iguales)
                    </code></pre>
                </section>
                
                <section>
                    <h4>Comprobación de tipos</h4>
                    <p>La función <code>typeof</code> permite obtener el tipo de un elemento. Devuelve una cadena con el nombre del tipo.</p>
                    <pre><code data-trim class="javascript">
var x = 3;
console.log(typeof(x));                         // &rarr; number
console.log(typeof("Hola"));                    // &rarr; string
console.log(typeof(variable_que_no_existe));    // &rarr; undefined
console.log(typeof(2 &lt; 9));                     // &rarr; boolean
console.log(typeof([1, 3, 5]));                 // &rarr; object
console.log(typeof(null));                      // &rarr; object
                    </code></pre>
                    <p>Aunque <code>null</code> es un tipo básico, <code>typeof(null)</code>
                        devuelve <code>"object"</code>.
                    </p>
                </section>
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 2</span><span style="display:none">:</span><br>Valores indefinidos, nulos, y <span style="text-transform:none">NaN</span></h3>
                    </div>
                </section>
                
                <section>
                    <h4>El valor indefinido (<code style="text-transform:none">undefined</code>)</h4>
                    <p>Se utiliza para las variables no inicializadas y para atributos no existentes dentro de objetos.</p>
                    <pre><code data-trim class="javascript">
var coordenadas = { x: 5, y: 6 };
var v;
console.log(v);                 // &rarr; undefined
console.log(coordenadas.z);     // &rarr; undefined
                    </code></pre>
                    <h4>El valor nulo (<code style="text-transform:none">null</code>)</h4>
                    <p>Se utiliza para denotar una referencia a objeto nula.</p>
                    <pre><code data-trim class="javascript">
var x = null;   // La variable 'x' esta inicializada, pero a una
                // referencia nula.
console.log(x); // &rarr; null                
                    </code></pre>
                </section>
                
                <section>
                    <h4>El valor Not-a-Number (<code style="text-transform:none">NaN</code>)</h4>
                    <p>Se devuelve como resultado de operaciones aritméticas incorrectas:</p>
                    <pre><code data-trim class="javascript">
Math.log(-2)    // &rarr; NaN
                    </code></pre>
                    <p><code>Infinity</code> y <code>-Infinity</code> se utilizan para desbordamientos, o para operaciones que devuelven &plusmn;&infin;</p>
                    <pre><code data-trim class="javascript">
Math.pow(2, 10000)  // &rarr; Infinity
Math.log(0)         // &rarr; -Infinity
                    </code></pre>
                </section>
                
                <section>
                    <p>¡Cuidado con las comparaciones de <code>NaN</code>!</p>
                    <pre><code data-trim class="javascript">
Math.log(-3) === NaN // &rarr; false
NaN === NaN          // &rarr; false
                    </code></pre>
                    <p>Si se quiere determinar si una operación ha dado <code>NaN</code> como resultado, debe utilizarse la función <code>isNaN</code></p>
                    <pre><code data-trim class="javascript">
isNaN(NaN)          // &rarr; true
isNaN(Math.log(-3)) // &rarr; true
                    </code></pre>
                </section>
                
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 3</span><span style="display:none">:</span><br>Las conversiones invisibles</h3>
                    </div>
                </section>
                
                <section>
                    <h4>Conversiones Javascript</h4>
                    <p>¿A qué valor se evalúan las siguientes expresiones?</p>
                    <pre><code data-trim class="javascript">
3 * 4               // &rarr; 12
"3" * 4             // &rarr; 12
"3" * "4"           // &rarr; 12
"3" * "pepe"        // &rarr; NaN
"12" + "20"         // &rarr; 1220
"12" + 20           // &rarr; 1220
12 + "20"           // &rarr; 1220
Math.log10("1000")  // &rarr; 3
"10" &lt; "2"          // &rarr; true
"10" &lt; 2            // &rarr; false
                    </code></pre>
                </section>
                
                <section>
                    <p>¿En qué casos se cumple la condición del <code>if</code>?</p>
                    <pre><code data-trim class="javascript">
if (23) { .... }            // &rarr; se cumple
if (-1) { .... }            // &rarr; se cumple
if (0) { .... }             // &rarr; no se cumple
if ("Pepe") { .... }        // &rarr; se cumple
if ("") { .... }            // &rarr; no se cumple
if ([1, 3]) { .... }        // &rarr; se cumple
if ([]) { .... }            // &rarr; se cumple
if (null) { .... }          // &rarr; no se cumple
if (undefined) { .... }     // &rarr; no se cumple
                    </code></pre>
                </section>
                
                <section>
                    <h4>Cómo evitar confusiones</h4>
                    <p>Con este panorama, hay dos alternativas:</p>
                    <ol>
                        <li>Aprenderse concienzudamente las reglas de conversión de Javascript:
                            <p>Información: <a href="http://webreflection.blogspot.com.es/2010/10/javascript-coercion-demystified.html">http://webreflection.blogspot.com.es/2010/10/javascript-coercion-demystified.html</a></p>
                        </li>
                        <li>
                            <strong>[Recomendado]</strong> Hacer las conversiones explícitamente, en caso de no estar seguro/a del tipo de una expresión
                            <p>Funciones <code>Number(...)</code>, <code>String(...)</code>, <code>Boolean(...)</code></p>
                        </li>
                    </ol>
                </section>
                
                <section>
                    <h4>Funciones de conversión</h4>
                    <p>La función <code>Number()</code></p>
                    <pre><code data-trim data-noescape class="javascript">
Number("32")        // &rarr; 32
Number("2f3")       // &rarr; NaN
Number(true)        // &rarr; 1
Number(false)       // &rarr; 0
Number(undefined)   // &rarr; NaN
Number(null)        // &rarr; 0
Number(new Date())  // &rarr; 1476191814528 (depende de fecha y hora)
                    </code></pre>
                    <p>Cuando la función <code>Number</code> se llama sobre un objeto <code>x</code>, se devuelve <code>x.valueOf()</code>.</p>
                    <p>Ver también: <code>parseInt</code> <a href="http://www.w3schools.com/jsref/jsref_parseint.asp">[+]</a></p>
                    
                </section>
                
                <section>
                    <p>La función <code>String()</code></p>
                    <pre><code data-trim class="javascript">
String(true)       // &rarr; "true"
String(undefined)  // &rarr; "undefined"
String(32)         // &rarr; "32"
String(new Date()) // &rarr; "Tue Oct 11 2016 15:23:02 GMT+0200 (CEST)"
                    </code></pre>
                    
                    <p>La función <code>String</code> aplicada sobre un objeto <code>x</code>
                    llama al método <code>x.toString()</code></p>
                </section>
                
                <section>
                    <p>La función <code>Boolean()</code></p>
                    <ul>
                        <li>Valores falsos: <code>undefined</code>, <code>null</code>, <code>false</code>, <code>0</code>, <code>NaN</code>, <code>""</code>.</li>
                        <li>Valores ciertos: el resto.</li>
                    </ul>
                    
                    <pre><code data-trim class="javascript">
Boolean("")         // &rarr; true
Boolean(34)         // &rarr; false
                    </code></pre>
                </section>
                
                
                <section>
                    <h4>Operadores de igualdad</h4>
                    <dl>
                        <dt><code>x === y</code> - Igualdad estricta</dt>
                        <dd><code>x</code> e <code>y</code> son del mismo tipo y tienen el mismo valor.</dd>
                        <dt><code>x == y</code> - Igualdad flexible</dt>
                        <dd><code>x</code> e <code>y</code> pueden convertirse al mismo tipo, de modo que tras hacer la conversión tienen el mismo valor.</dd>
                    </dl>
                    
                    <pre><code data-trim class="javascript">
"25" == 25      // &rarr; true
"25" === 25     // &rarr; false
false == 0      // &rarr; true
"" == 0         // &rarr; true
2.0 === 2       // &rarr; true (recuerda: no se distingue entre tipo
                //         de enteros y de coma flotante)

                    </code></pre>
                    
                    <p>También se definen <code>!=</code> y <code>!==</code> como la negación de <code>==</code> y <code>===</code> respectivamente.</p>
                </section>
                
                <section>
                    <h4>Moraleja</h4>
                    <p style="background-color:#007000; color:white; padding: 80px 20px; font-size: 200%">Utiliza siempre
                    <span style="font-family: monospace">===</span> y <span style="font-family: monospace">!==</span></p>
                </section>
                
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 4</span><span style="display:none">:</span><br>Argumentos que sobran y faltan</h3>
                    </div>
                </section>
                
                <section>
                    <h4>Definición de una función</h4>
                    <pre><code data-trim class="javascript">
function imprime_args(p1, p2, p3) {
    console.log("p1: " + p1);
    console.log("p2: " + p2);
    console.log("p3: " + p3);
}

                    </code></pre>
                    <h4>Llamada a una función</h4>
                    <pre><code data-trim class="javascript">
imprime_args(1, "bar", true);
                    </code></pre>
                    <p>Resultado:</p>
                    <pre>
p1: 1
p2: bar
p3: true</pre>
                </section>
                
                <section>
                    <p>El número de argumentos en la llamada a la función no ha de coincidir necesariamente con el número de parámetros en la definición</p>
                    
                    <ul>
                        <li>Si se proporcionan argumentos &laquo;de más&raquo; se ignoran los sobrantes:
                        <pre><code data-trim class="javascript">
imprime_args("uno", "dos", "tres", "cuatro");
                        </code></pre>
                        <pre>
p1: uno
p2: dos
p3: tres</pre>
                        </li>
                        <li>
                            Si faltan argumentos, los parámetros correspondientes tomarán el valor <code>undefined</code>
                            <pre><code data-trim class="">
imprime_args("uno", "dos");
                            </code></pre>
                        <pre>
p1: uno
p2: dos
p3: undefined</pre>                           
                        </li>
                    </ul>
                </section>
                
                <section>
                    <p>Lo anterior permite definir funciones con parámetros opcionales.</p>
                    <pre><code data-trim class="javascript">
/*
    El parámetro 'color' es opcional. Su valor por defecto
    es 'negro'.
    
    El parámetro 'trazo' especifica el grosor del trazo y
    también es opcional. Su valor por defecto es 1.
*/
function pintar_circulo(x, y, color, trazo) {
    if (color === undefined) color = "negro";
    if (trazo === undefined) trazo = 1;
    
    console.log("Pintar círculo en (" + x + ", " + y + ")" +
                " con color " + color + 
                " y trazo de grosor " + trazo);
}
                   </code></pre>
                </section>
                
                <section>
                    <p>Implementación alternativa:</p>
                    <pre><code data-trim class="javascript">
/*
    El parámetro 'color' es opcional. Su valor por defecto
    es 'negro'.
    
    El parámetro 'trazo' especifica el grosor del trazo y
    también es opcional. Su valor por defecto es 1.
*/
function pintar_circulo(x, y, color, trazo) {
    color = color || "negro";
    trazo = trazo || 1;
    
    console.log("Pintar círculo en (" + x + ", " + y + ")" +
                " con color " + color + 
                " y trazo de grosor " + trazo);
}
                   </code></pre>
                    <p>¿Es correcta?</p>
                </section>
                
                <section>
                    <h4>Número variable de parámetros</h4>
                    <p>La variable especial <code>arguments</code> contiene la lista
                    de argumentos recibidos por la función</p>
                    <pre><code data-trim class="javascript">
/*
    Devuelve el resultado de sumar los números pasados como
    parámetros. Los argumentos que no sean números se ignoran.
*/
function suma() {
    var result = 0;
    for (var i = 0; i &lt; arguments.length; i++) {
        if (typeof(arguments[i]) === "number") {
            result += arguments[i];
        }
    }
    return result;
}
                    </code></pre>
                    <pre><code data-trim class="javascript">
suma(3, 4, "foo", 9)    // &rarr; 16
                    </code></pre>
                </section>
                
                <section>
                    <h4>Parámetros nominales</h4>
                    <p>Utilizando objetos podemos simular el paso de parámetros nominales.</p>
                    <p>Por ejemplo, supongamos una función <code>abrir_fichero</code> que espera
                    un nombre de fichero y, opcionalmente:</p>
                    <ul>
                        <li><p>Un parámetro <code>solo_lectura</code> que indica si el fichero se abre en modo lectura o en modo lectura/escritura.</p>
                            <p>Valor por defecto: <code>true</code></p>
                        </li>
                        <li><p>Un parámetro <code>binario</code> que indica si el fichero es binario o no.</p>
                            <p>Valor por defecto: <code>false</code></p>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <p>Ejemplos de llamadas</p>
                    <pre><code data-trim class="javascript">
abrir_fichero("mio.txt");
// Abriendo fichero mio.txt en modo lectura

abrir_fichero("mio.txt", { solo_lectura: false });
// Abriendo fichero mio.txt en modo lectura/escritura

abrir_fichero("mio.txt", { binario: true });
// Abriendo fichero binario mio.txt en modo lectura

abrir_fichero("mio.txt", { binario: true, solo_lectura: false });
// Abriendo fichero binario mio.txt en modo lectura/escritura

abrir_fichero("mio.txt", { solo_lectura: true, binario: false });
// Abriendo fichero mio.txt en modo lectura
                    </code></pre>
                </section>
                
                <section>
                    <p>Implementación:</p>
                    <pre><code data-trim class="javascript">
/*
    El objeto 'ops' tiene como atributos los parámetros
    opcionales.
*/
function abrir_fichero(nombre, ops) {
    // Si no se han pasado parámetros opcionales, el objeto
    // 'ops' habrá tomado el valor undefined. Lo inicializamos
    // al objeto vacío.
    if (ops === undefined) ops = {};
    
    // Inicialización de los parámetros opcionales no pasados
    if (ops.solo_lectura === undefined) ops.solo_lectura = true;
    if (ops.binario      === undefined) ops.binario      = false;
    
    // Cuerpo de la función
    console.log("Abriendo fichero "
        + (ops.binario ? "binario " : "")
        + nombre + " en modo "
        + (ops.solo_lectura ? "lectura" : "lectura/escritura"));
        
}                    
                    </code></pre>
                </section>
            
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 5</span><span style="display:none">:</span><br>Las funciones son ciudadanos de primera clase</h3>
                    </div>
                </section>
                
                <section>
                    <h4>¿Qué significa eso?</h4>
                    <p>Que las funciones son tratadas como objetos.</p>
                    <p>En particular:</p>
                    <ul style="color:#008dbc">
                        <li>Se puede asignar una función a una variable.</li>
                        <li>Pueden pasarse funciones como parámetros.</li>
                        <li>Pueden recibirse funciones como resultados.</li>
                    </ul>
                    
                    <p>Esta característica es compartida por muchos lenguajes funcionales e imperativos:</p>
                    <p>Haskell, Scala, Erlang, C, C++, Java 8, etc.</p>
                </section>
                
                <section>
                    <p>Partimos de las siguientes definiciones:</p>
                    <pre><code data-trim class="javascript">
function incrementar(x) {
    return x + 1;
}

function duplicar(x) {
    return 2 * x;
}

function cuadrado(y) {
    return y * y;
}

function factorial(n) {
    if (n &lt;= 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
                    </code></pre>
                </section>
                
                <section>
                    <p>Asignamos algunas de estas funciones a la variable <code>f</code>:</p>
                    <pre><code data-trim class="">
var f = incrementar;
console.log(f(5));
// Imprime: 6

f = factorial;
console.log(f(10));
// Imprime: 3628800
                    </code></pre>
                    
                    <p>¡Cuidado con los paréntesis!</p>
                    <pre><code data-trim class="">
var f = incrementar();  // INCORRECTO
// Esto realiza la llamada incrementar(undefined), y devuelve el
// valor resultante (que también es undefined a f).

console.log(f(5));
// ERROR: f no es una función
                    </code></pre>
                </section>
                
                
                <section>
                    <p>La siguiente función recibe una lista de funciones y un valor. Aplica
                    cada una de las funciones de la lista al valor dado y muestra los resultados
                    por consola:</p>
                    <pre><code data-trim class="javascript">
function aplicar_funciones(funs, z) {
    for (var i = 0; i &lt; funs.length; i++) {
        console.log("Aplicar función " + i +
                    " pasando " + z + ": " + funs[i](z));
    }
}
                    </code></pre>
                    <p>Ejemplo:</p>
                    <pre><code data-trim class="javascript">
aplicar_funciones([incrementar,duplicar,cuadrado,factorial], 5);
                    </code></pre>
                    <pre>
Aplicar función 0 pasando 5: 6
Aplicar función 1 pasando 5: 10
Aplicar función 2 pasando 5: 25
Aplicar función 3 pasando 5: 120</pre>
                </section>
                
                <section>
                    <p>De igual modo, se puede devolver una función como resultado:</p>
                    <pre><code data-trim class="javascript">
function buscar_por_nombre(nombre) {
    switch(nombre) {
        case "INC": return incrementar;
        case "DUP": return dup;
        case "SQR": return cuadrado;
        case "FCT": return factorial;
    }
    // Si la función termina sin alcanzar un return,
    // se considera que devuelve undefined
}
                    </code></pre>
                    <p>Ejemplo:</p>
                    <pre><code data-trim class="javascript">
var g = buscar_por_nombre("INC");
console.log(g(10));                    
                    </code></pre>
                    <pre>
11</pre>
                </section>
                
                <section>
                    <h4>Funciones como expresiones</h4>
                    <p>Se puede utilizar una definición de función en cualquier sitio donde se espere una expresión.</p>
                    <p>En estos casos es posible omitir el nombre de la función (<strong>función anónima</strong>)</p>
                    <pre><code data-trim class="javascript">
var f = function() { console.log("Hola"); };
f();

var g = function(x, y) { return x + y; };
console.log(g(3, 5));
                    </code></pre>
                </section>
                
                <section>
                    <p>En el ejemplo anterior:</p>
                    <pre><code data-trim class="javascript">
aplicar_funciones(
    [ function(x) { return x - 3; },
      function(x) { return Math.sqrt(x); },
      factorial,
      function(z) { return Math.log(z); }  ], 2);                    
                    </code></pre>
                    <pre>
Aplicar función 0 pasando 2: -1
Aplicar función 1 pasando 2: 1.4142135623730951
Aplicar función 2 pasando 2: 2
Aplicar función 3 pasando 2: 0.6931471805599453</pre>
                    
                    <p>¿Puede reemplazarse la referencia a <code>factorial</code> 
                        por otra función anónima?</p>
                </section>
                
                <section>
                    <h4>Ámbito de variables</h4>
                    <p>Las variables declaradas dentro de una función tienen como ámbito dicha función:</p>
                    <pre><code data-trim class="javascript">
function f(n) {
    var x = ...;
    // x está en ámbito dentro de la función
}

// aquí x está fuera de ámbito
                    </code></pre>
                </section>
                
                <section>
                    <p><strong>Solamente las funciones definen ámbitos</strong></p>
                    <p>El resto de bloques no.</p>
                    <pre><code data-trim class="javascript">
if (...) {
    var z = ...;
}

// La z está en ámbito fuera del if-then

for (var x = 0; x &lt; 10; x++) {
    var y = ...;
}

// Tanto 'x' como 'y' están en ámbito a la salida
// del bucle.
                    </code></pre>
                    <p>Puede arreglarse mediante <em>expresiones funcionales invocadas inmediatamente</em> (IIFE) <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">[+]</a></p>
                </section>
                
                <section>
                    <h4>Clausuras</h4>
                    <p>Una función puede hacer referencia a variables declaradas en un ámbito superior</p>
                    <pre><code data-trim data-noescape class="javascript">
var y = 3;  // variable global

var f = function(x) {
    return x + y;   <span class="arrow_box_left caja_codigo">Referencia a la variable global y</span>
}

console.log(f(5));
// Imprime: 8
                    </code></pre>
                    <p>¿Y si cambio el valor de la variable <code>y</code> después de definir <code>f</code>?</p>
                    <pre><code data-trim class="javascript">
y = 9;
console.log(f(2));
// Imprime: 11
                    </code></pre>
                </section>
                
                <section>
                    <h4>Más difícil todavía</h4>
                    <p>Supongamos el siguiente caso</p>
                    <pre><code data-trim class="javascript">
var z = 3;  // Variable global

function g() {
    var z = 7;     // Variable local; oculta a la global
    var f = function(x) { return z + x; };
    console.log(f(1));
}

g();
                    </code></pre>
                    <p>¿Qué imprime <code>g()</code>?</p>
                    <pre>8   // es decir: 7 + 1</pre>
                    <p>En la expresión <code>z + x</code> dentro de la definición de <code>f</code>, la aparición de <code>z</code> se liga a la variable <code>z</code> definida dentro de <code>g</code>, que es la que está en ámbito en el momento de crear la función <code>f</code>. </p>
                </section>
                
                <section>
                    <h4>Y aún más difícil</h4>
                    <p>Ahora &laquo;sacamos&raquo; la función <code>f</code> del ámbito <code>g</code> devolviéndola como resultado:</p>
                    <pre><code data-trim class="javascript">
var z = 3;  // Variable global

function g() {
    var z = 7;  // Variable local; oculta a la global
    return function(x) { return z + x; };
}

// La variable local z ya no está en ámbito,
// Pero la variable global z sí lo está
var h = g();

// ¿Qué imprime esto? ¿3 + 5? ¿7 + 5?
console.log(h(5));                    
                    </code></pre>
                    <p>Resultado:</p>
                    <pre>12</pre>
                </section>
                
                <section>
                    <pre><code data-trim class="javascript">
function g() {
    var z = 7;
    return function(x) { return z + x; };
}
                    </code></pre>
                    <p>En la expresión <code>function(x) { return z + x; }</code>, la aparición de <code>z</code> queda ligada a la variable <code>z</code> local en <code>g</code>, que es la que está en ámbito en el momento de crear la función. Este vínculo es <strong>permamente</strong>.
                    </p>
                    <p>Tras crear la función anónima, cualquier llamada  la misma utilizará siempre esta variable <code>z</code>, ¡aunque ya esté fuera de ámbito en el momento de realizar la llamada!</p>
                </section>
                
                <section>
                    <div style="background-color:#F0BfDf; padding: 20px 20px">
                        Cuando se crea una función que hace referencia a nombres de variables externas, esos nombres siempre referenciarán a las variables que estuviesen en ámbito <strong>en el momento de crear la función</strong>.
                    </div>
                </section>
                
                <section>
                    <h4>Ejemplo: incrementador</h4>
                    <pre><code data-trim class="javascript">
function incrementador(n) {
    return function(x) { return x + n; };
}                    
                    </code></pre>
                    <pre><code data-trim class="javascript">
var inc1 = incrementador(1);
console.log(inc1(5)); // &rarr; 6
console.log(inc1(9)); // &rarr; 10
                    </code></pre>
                    <pre><code data-trim class="javascript">
var inc3 = incrementador(3);
console.log(inc3(5)); // &rarr; 8
console.log(inc3(9)); // &rarr; 12        
                    </code></pre>
                </section>
                
                <section  data-transition="slide-in fade-out">
                    <img src="images/03/Inc1.svg" style="width:100%; border:none">
                    <p>Al comenzar la llamada a <code>incrementador(1)</code> se crea un entorno con el valor de la variable local <code>n = 1</code> </p>
                </section>

                <section data-transition="fade-in fade-out">
                    <img src="images/03/Inc2.svg" style="width:100%; border:none">
                    <p>La llamada a <code>incrementador(1)</code> devuelve una función en la que
                    la <code>n</code> está ligada al entorno correspondiente.</p>
                </section>                

                <section data-transition="fade-in fade-out">
                    <img src="images/03/Inc3.svg" style="width:100%; border:none">
                    <p>Al llamar a <code>incrementador(3)</code> se crea otro entorno distinto en el que <code>n = 3</code>.</p>
                </section>
                
                <section data-transition="fade-in slide-out">
                    <img src="images/03/Inc4.svg" style="width:100%; border:none">
                    <p>La función creada en esta llamada tiene la variable <code>n</code> ligada
                    a la  <code>n</code> de este último entorno.</p>
                </section>
                
                <section>
                    <h4>Ejemplo: contador</h4>
                    <pre><code data-trim class="javascript">
function contador() {
    var n = 1;
    return function() {
                return n++;
           }
}

var c1 = contador();
var c2 = contador();

console.log(c1());  // &rarr; 1
console.log(c1());  // &rarr; 2
console.log(c1());  // &rarr; 3
console.log(c2());  // &rarr; 1
console.log(c2());  // &rarr; 2
console.log(c1());  // &rarr; 4
                    </code></pre>
                </section>
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 6</span><span style="display:none">:</span><br>Javascript tiene objetos,<br> pero no clases</h3>
                    </div>
                </section>
                
                <section>
                    <h4>Objetos</h4>
                    <p>Un <strong>objeto</strong> es una colección de <strong style="color:#5050FF">atributos</strong>, cada uno de ellos  asociado a un <strong style="color:#5050FF">valor</strong>.</p>
                    <pre><code data-trim class="javascript">
var x = {
    nombre: "Ana María",
    apellidos: "Gamboa Esteban",
    edad: 54
};                    
                   </code></pre>
                    <p>El literal <code>{}</code> representa un objeto vacío (sin atributos)</p>
                    <pre><code data-trim class="javascript">
var y = {};                    
                    </code></pre>
                </section>
                
                <section>
                    <p>El acceso a los atributos de un objeto se realiza mediante:</p>
                    <ul style="width: 100%">
                        <li>El operador punto (<code>.</code>)
                            <pre><code data-trim class="javascript">
x.apellidos // &rarr; "Gamboa Esteban"
                            </code></pre>
                        </li>
                        <li>o bien, el operador corchete
                            <pre><code data-trim class="javascript">
x["apellidos"] // &rarr; "Gamboa Esteban"                            
                            </code></pre>
                            <pre><code data-trim class="javascript">
var atrib = "nombre";
x[atrib] // &rarr; "Ana María"
                            </code></pre>
                        </li>
                    </ul>
                    <p>El acceso a una propiedad inexistente devuelve <code>undefined</code></p>
                    <pre><code data-trim class="javascript">
x.noexiste  // &rarr; undefined
y.nombre    // &rarr; undefined
                    </code></pre>
                </section>
                
                <section>
                    <p>Modificación de atributos:</p>
                    <pre><code data-trim class="javascript">
x.edad = x.edad + 1;  // o bien: x.edad++
x.["nombre"] = "Ana Josefa";
                    </code></pre>
                    <p>Es posible añadir atributos dinámicamente en cualquier momento:</p>
                    <pre><code data-trim class="javascript">
x.direccion = "Calle Bautista, 25";
y.nombre = "Javier";

console.log(x);
 // { nombre: 'Ana Josefa', apellidos: 'Gamboa Esteban', edad: 55 }
console.log(y);
 // { nombre: 'Javier' }
                    </code></pre>
                    <p>...y también borrarlos:</p>
                    <pre><code data-trim class="javascript">
delete x.edad;
console.log(x);
 // { nombre: 'Ana Josefa', apellidos: 'Gamboa Esteban' }

                    </code></pre>
                </section>
                
                <section>
                    <p>Los nombres de atributos no han de ser necesariamente identificadores válidos de Javascript. Los nombres especiales han de ir entre comillas:</p>
                    <pre><code data-trim class="javascript">
var z = {
    "Atributo con espacios": 21,
    "14": "foo",
    "false": "ok"
};
                    </code></pre>
                    <p>Para acceder a atributos con nombres especiales solamente se puede utilizar la notación corchete</p>
                    <pre><code data-trim class="javascript">
z["Atributo con espacios"] = 22;
                    </code></pre>
                </section>
                
                <section>
                    <p>La función <code>Object.keys()</code> devuelve un array con las  claves de un objeto:</p>
                    <pre><code data-trim class="javascript">
var x = {
    nombre: "Ana María",
    apellidos: "Gamboa Esteban",
    edad: 54
};

console.log(Object.keys(x));
    // [ 'nombre', 'apellidos', 'edad' ]
                    </code></pre>
                    <p>El operador <code>in</code> permite determinar la existencia de un atributo dentro de un objeto:</p>
                    <pre><code data-trim class="javascript">
if ("edad" in x) {
    console.log("x tiene un atributo llamado 'edad'");
}                    
                    </code></pre>
                </section>
                
                <section>
                    <h4>Igualdad de objetos</h4>
                    <p>Cuando se aplica el operador <code>==</code> o <code>===</code> sobre objetos, se comprueba que los objetos a ambos lados del operador son el mismo (igualdad al estilo de Java)</p>
                    <pre><code data-trim class="javascript">
var coords1 = { x: 20, y: 30 };
var coords2 = { x: 20, y: 30 };
var coords3 = coords1;

console.log(coords1 === coords2);
    // &rarr; false
    
console.log(coords1 === coords3);
    // &rarr; true
                    </code></pre>
                    <p><strong>Recuerda:</strong> en Javascript, las cadenas no son objetos; son tipos básicos.</p>
                </section>
                
                <section>
                    <h4>Funciones dentro de objetos</h4>
                    <p>Como las funciones son ciudadanos de primera clase, pueden ser asignadas a los atributos de un objeto:</p>
                    <pre><code data-trim class="javascript">
var empleado = {
    nombre: "Manuel",
    saludar: function() {
        console.log("¡Hola!");
    }
};

empleado.saludar();
    // &rarr; ¡Hola!
                    </code></pre>
                    <p>Este tipo de funciones reciben el nombre de <strong>métodos</strong>.</p>
                    <p>Se puede añadir métodos a un  objeto ya construido:</p>
                    <pre><code data-trim class="javascript">
empleado.despedir = function() { console.log("¡Adios!"); };
empleado.despedir();
                    
                    </code></pre>
                </section>
                
                <section>
                    <h4>El objeto <code style="text-transform:none">this</code></h4>
                    <p style="font-family:monospace">
                        <span style="background-color:#A4A430; padding:2px; border-radius: 6px">empleado</span>.<span style="background-color:#B080B0; padding:2px; border-radius: 6px">saludar</span>();
                    </p>
                    <p>En toda llamada a método se distinguen tres componentes:</p>
                    <ul>
                        <li>Método llamado: <span style="background-color:#B080B0; padding:2px; border-radius: 6px; font-family:monospace">saludar</span></li>
                        <li>Argumentos (ninguno, en este caso)</li>
                        <li>Objeto sobre el que se realiza la llamada: <span style="background-color:#A4A430; padding:2px; border-radius: 6px; font-family:monospace">empleado</span></li>
                    </ul>
                    <p>Cuando llamamos a un método, éste recibe, además de los correspondientes
                    argumentos, una variable especial (<code>this</code>) que contiene una referencia al objeto sobre el que se realiza la llamada.</p>
                </section>
                
                <section>
                    Ejemplo:
                    <pre><code data-trim data-noescape class="javascript">
var empleado = {
    nombre: "Manuel",
    
    saludar: function() {
        console.log("¡Hola, " + <span style="background-color:#D4D430; padding:2px; border-radius: 6px">this</span>.nombre + "!");
    }
    
    cambiarNombre: function(nuevoNombre) {
        <span style="background-color:#D4D430; padding:2px; border-radius: 6px">this</span>.nombre = nuevoNombre;
    }
};
                    </code></pre>
                    
                    <pre><code data-trim class="javascript">
empleado.saludar();
    // &rarr; ¡Hola, Manuel!
    
empleado.cambiarNombre("Irene");

empleado.saludar();
    // &rarr; ¡Hola, Irene!
                    </code></pre>
                    
                </section>
                
                <section>
                    <p>Pueden transferirse métodos entre distintos objetos: </p>
                    <pre><code data-trim data-noescape class="javascript">
var otro_empleado = {
    nombre: "David",
    saludar: empleado.saludar
};

<span style="background-color:#D4D430; padding:2px; border-radius: 6px">otro_empleado</span>.saludar();
    // &rarr; ¡Hola, <span style="background-color:#D4D430; padding:2px; border-radius: 6px">David</span>!
                    </code></pre>
                    <p>Se imprime el nombre de <code>otro_empleado</code>, porque es el objeto que recibe la llamada, aunque se llame a un método proveniente de otro objeto.</p>
                    
                    <p>¿Qué ocurre al ejecutar el siguiente código?</p>
                    <pre><code data-trim class="javascript">
var f = empleado.saludar;
f();
                    </code></pre>
                </section>
                
                <section>
                    <p>Podemos encapsular la creación de objetos mediante funciones constructoras:</p>
                    <pre><code data-trim class="javascript">
function construirComplejo(real, imag) {
    return {
        r : real,
        i : imag,
        
        modulo: function() {
            return Math.sqrt(this.r * this.r + this.i * this.i);
        },
        
        argumento: function() {
            return Math.atan2(this.i, this. r);
        }
        
    }
}

var c1 = construirComplejo(-3, 0);
console.log(c1.argumento());  // &rarr; 3.141592653589793
var c2 = construirComplejo(1, 1);
console.log(c2.modulo());     // &rarr; 1.4142135623730951
                    </code></pre>
                    <p style="font-size:60%">(Más adelante veremos otra forma de crear funciones constructoras)</p>
                </section>
                
                <section>
                    <p>Problema: duplicidad de objetos función para cada objeto.</p>
                    <img src="images/03/DosComplejos.svg" style="height:100%; border:none">
                    <p>¿No podrían <code>c1</code> y <code>c2</code> compartir los métodos?</p>
                </section>
                
                <section>
                    <p>Posible solución:</p>
                    <pre><code data-trim class="javascript">
function moduloComplejo() {
    return Math.sqrt(this.r * this.r + this.i * this.i);
}

function argumentoComplejo() {
    return Math.atan2(this.i, this. r);
}

function construirComplejo(real, imag) {
    return {
        r : real,
        i : imag,
        modulo: moduloComplejo,
        argumento: argumentoComplejo
    }
}
                    </code></pre>
                </section>
                
                <section>
                    <img src="images/03/DosComplejosComparten.svg" style="width:95%; border:none">
                </section>
                
                <section>
                    <p>Añadimos un método nuevo a <code>c1</code>:</p>
                    <pre><code data-trim class="javascript">
var c1 = construirComplejo(-3, 0);
var c2 = construirComplejo(1, 1);

// ...

c1.coordenadasPolares = function() {
    console.log("(" + this.modulo() + ", " 
                    + this.argumento() + ")");
}
                    </code></pre>
                    <p>Este método existe solamente dentro de <code>c1</code>.</p>
                    <div style="background-color: #F0D0D0">
                    <p>¿Existe alguna manera de añadir un método simultáneamente a todos los objetos que hubiesen sido creados mediante <code>construirComplejo</code>?</p>
                    <p>Sí. Se puede hacer mediante <strong>prototipos</strong>.</p>
                    </div>
                </section>
                
                <section>
                    <h4>Prototipo de un objeto</h4>
                    <p>Todo objeto en Javascript tiene un puntero &laquo;secreto&raquo; que puede apuntar a otro objeto:</p>
                    <img src="images/03/ComplejoPrototipo.svg" style="width:40%;border:none;box-shadow:none">
                    <p>... o puede ser un puntero nulo:</p>
                    <img src="images/03/ComplejoPrototipo2.svg" style="width:23%;border:none;box-shadow:none">
                </section>
                
                <section>
                    <img src="images/03/CadenaPrototipos1.svg" style="width:50%;border:none;box-shadow:none">
                    <p>En el primer caso decimos que el objeto apuntado es <strong>prototipo</strong> de <code>c1</code>.</p>
                </section>
                
                <section>
                    <p>A su vez, <code>c2</code> puede tener otro prototipo:</p>
                    <img src="images/03/CadenaPrototipos2.svg" style="width:80%;border:none;box-shadow:none">
                    <p>De este modo tenemos una <strong>cadena de prototipos</strong>, que acabará en un objeto que tenga el puntero &laquo;oculto&raquo; a <code>null</code>.</p>
                </section>
                
                <section>
                    <h4>Búsqueda de atributos</h4>
                    <p>¿Qué ocurre cuando se accede al atributo de un objeto?</p>
                    <p>Supongamos la expresión <code>c1.nombre</code></p>
                </section>
                
                <section>
                    <p><code>c1.nombre</code></p>
                    <img src="images/03/CadenaPrototipos3.svg" style="width:80%;border:none;box-shadow:none">
                    <p>En primer lugar se intenta buscar un atributo llamado <code>nombre</code> dentro de <code>c1</code>.</p>
                </section>

                <section>
                    <p><code>c1.nombre</code></p>
                    <img src="images/03/CadenaPrototipos4.svg" style="width:80%;border:none;box-shadow:none">
                    <p>Si no se encuentra en <code>c1</code>, se busca el atributo dentro del prototipo de <code>c1</code>.</p>
                </section>
                
                <section>
                    <img src="images/03/CadenaPrototipos5.svg" style="width:80%;border:none;box-shadow:none">
                    <p>Si no se encuentra en el prototipo de <code>c1</code>, se busca el dentro del prototipo del prototipo de <code>c1</code>.
                        Si no se encuentra allí, la búsqueda continúa por la cadena de prototipos hasta que:
                    </p>
                    <ul>
                        <li>Se encuentre el atributo en la cadena.</li>
                        <li>Se llegue al final de la cadena. En este caso la expresión <code>c1.nombre</code> se evalúa a <code>undefined</code>.</li>
                    </ul>
                    
                </section>
                
                <section>
                    <h4>Crear objetos a partir de un prototipo</h4>
                    <p>Se utiliza la función <code>Object.create()</code></p>
                    <p>La siguiente sentencia:</p>
                    <pre><code data-trim class="javascript">
var y = Object.create(x);
                    </code></pre>
                    <p>crea un objeto <code>y</code> que tiene a <code>x</code> como prototipo:</p>
                    <img src="images/03/PrototiposXY.svg" style="width:50%;border:none;box-shadow:none">
                </section>
                
                <section>
                    Ejemplo:
                    <pre><code data-trim class="javascript">
var circulo = {
    centro: { x: 10, y: 20 },
    radio: 5
};

var circulo_verde = Object.create(circulo);
circulo_verde.color = "verde";


var circulo_rojo = Object.create(circulo);
circulo_rojo.color = "rojo";
                    </code></pre>
                    
                    <pre><code data-trim class="javascript">
console.log(circulo_rojo.color);        // &rarr; "rojo"
console.log(circulo_verde.radio);       // &rarr; 5
console.log(circulo_verde.centro.x);    // &rarr; 10
console.log(circulo_rojo.centro);       // &rarr; { x: 10, y: 20 }
                    </code></pre>
                    
                </section>
                
                <section>
                    <h4>Cambiar y añadir atributos al prototipo</h4>
                    <p>Añadimos lo siguiente al ejemplo anterior:</p>
                    <pre><code data-trim class="javascript">
                    circulo.grosorBorde = 2;
                    </code></pre>
                    <p>¿Qué ocurre con <code>circulo_verde</code> y <code>circulo_rojo</code>?</p>
                    <pre><code data-trim class="javascript">
console.log(circulo_rojo.grosorBorde);      // &rarr; 2
console.log(circulo_verde.grosorBorde);     // &rarr; 2
                    </code></pre>
                    <p>&laquo;Heredan&raquo; automáticamente el nuevo atributo.</p>
                    <p>Lo mismo ocurre con las modificaciones al prototipo:</p>
                    <pre><code data-trim class="javascript">
circulo.radio = 6;

console.log(circulo_rojo.radio);    // &rarr; 6
console.log(circulo_verde.radio);   // &rarr; 6      
                    </code></pre>
                </section>
                
                <section>
                    <h4>Sobreescritura de atributos</h4>
                    <p>Un objeto puede sobreescribir cualquier atributo heredado de su prototipo:</p>
                    <pre><code data-trim class="">
circulo_rojo.radio = 3;
                    </code></pre>
                    <pre><code data-trim class="javascript">
console.log(circulo_rojo.radio);    // &rarr; 3
console.log(circulo_verde.radio);   // &rarr; 6
                    </code></pre>
                    <p>El atributo sobreescrito no afecta a los demás objetos que tengan el mismo protoipo.</p>
                </section>
                
                <section>
                    <p><code>circulo_rojo.radio = 3;</code></p>
                    <img src="images/03/CirculosRojoyVerde.svg" style="width:60%;border:none;box-shadow:none">
                    
                    <p>¿Qué ocurre con lo siguiente?</p>
                    <pre><code data-trim class="javascript">
circulo_rojo.centro.x = 15;
console.log(circulo_verde.centro.x);
                    </code></pre>
                </section>
                
                <section>
                    <p>Volviendo al ejemplo de los números complejos</p>
                    <img src="images/03/DosComplejosComparten.svg" style="width:95%; border:none">
                </section>
                
                <section>
                    <pre><code data-trim class="javascript">
var prototipoComplejo = {
    modulo: function() {
        return Math.sqrt(this.r * this.r + this.i * this.i);
    },
    argumento: function() {
        return Math.atan2(this.i, this. r);
    }
};


function construirComplejo(real, imag) {
    var resultado = Object.create(prototipoComplejo);
    resultado.r = real;
    resultado.i = imag;
    return resultado;
}                    
                    </code></pre>
                    <pre><code data-trim class="javascript">
var c1 = construirComplejo(-3, 0);
var c2 = construirComplejo(1, 1);                    
                    </code></pre>
                </section>
                
                
                <section>
                    <p>Todas las funciones que se añadan al prototipo estarán disponibles automáticamente para todos los objetos que hayan sido creados previamente por <code>construirComplejo</code></p>
                    <pre><code data-trim class="javascript">
// Añadimos una nueva función al prototipo:

prototipoComplejo.coordenadasPolares = function() {
  console.log("(" + this.modulo() + ", " + this.argumento() + ")");
}

c1.coordenadasPolares();
    // &rarr; (3, 3.141592653589793)
    
c2.coordenadasPolares();
    // &rarr; (1.4142135623730951, 0.7853981633974483)
                    </code></pre>
                </section>
                
                <section>
                    <h4>El objeto <code style="text-transform:none">Object.prototype</code></h4>
                    <p>Salvo que haya sido creado mediante <code>Object.create</code>, un objeto tiene como prototipo <code>Object.prototype</code>.</p>
                    <p><code>Object.prototype</code> tiene algunos métodos predefinidos:</p>
                    <ul>
                        <li><code>toString()</code></li>
                        <li><code>valueOf()</code></li>
                        <li><code>isPrototypeOf()</code></li>
                        <li><code>hasOwnProperty()</code></li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">[+]</a></li>
                    </ul>
                </section>

                <section>
                    <h4>Ejemplos</h4>
                    <pre><code data-trim class="javascript">
var c3 = construirComplejo(1, 3);

console.log(c3.toString());
    // &rarr; [object Object]

prototipoComplejo.toString = function() {
    return "(" + this.r + ", " + this.i + ")";
}

console.log(c3.toString());
    // &rarr; (1, 3)
                    </code></pre>
                    <pre><code data-trim class="javascript">
console.log(prototipoComplejo.isPrototypeOf(c3));
    // &rarr; true
                    </code></pre>
                </section>
                
                <section>
                    <h4>Evitar la herencia de  <code style="text-transform:none">Object.prototype</code></h4>
                    <p>Basta con crear un objeto mediante <code>Object.create</code> pasando <code>null</code> como prototipo.</p>
                    <pre><code data-trim class="javascript">
var objeto_vacio = Object.create(null);
objeto_vacio.toString();    // ERROR
                    </code></pre>
                </section>
                
                <section>
                    <p>El operador <code>in</code> tiene en cuenta tanto los atributos propios como los heredados:</p>
                    <pre><code data-trim class="javascript">
var c4 = construirComplejo(1, 3);
console.log("r" in c4);             // &rarr; true
console.log("modulo" in c4);        // &rarr; true
                    </code></pre>
                    <p>Si se desea comprobar la existencia de un atributo propio, ha de utilizarse el método <code>hasOwnProperty()</code>:</p>
                    <pre><code data-trim class="javascript">
console.log(c4.hasOwnProperty("r"));        // &rarr; true
console.log(c4.hasOwnProperty("modulo"));   // &rarr; false
                    </code></pre>
                </section>
                
                <section>
                    <h4>Descriptores de objeto</h4>
                    <p>Hasta ahora todos los atributos de un objeto permiten la lectura y escritura de su valor asociado.</p>
                    <p>Mediante el método <code>Object.defineProperty()</code> podemos configurar los atributos de un objeto.</p>
                    <pre><code data-trim class="javascript">
var x = {};

Object.defineProperty(x, "ancho", {
    value: 10,
    writable: false
});

console.log(x.ancho);
x.ancho = 20; // ERROR
                    </code></pre>
                </section>
                
                <section>
                    <p>Esto permite encapsular el acceso a un atributo:</p>
                    <pre><code data-trim class="javascript">
x.__alto = 10; // Este es el atributo "privado"

Object.defineProperty(x, "alto", {
    // Método de acceso
    get : function() { return this.__alto; },

    // Método de modificación
    set: function(nuevoAlto) {
        if (nuevoAlto &lt; 0) {
            this.__alto = 0;
        } else if (nuevoAlto &gt; 100) {
            this.__alto = 100;
        } else {
            this.__alto = nuevoAlto;
        }
    }
});

x.alto = -5;
console.log(x.alto);    // &rarr; 0

x.alto = 21;
console.log(x.alto);    // &rarr; 21

                    
                    </code></pre>
                </section>
                
                <section>
                    <p>La función <code>defineProperty()</code> recibe un objeto como tercer parámetro que define las propiedades del atributo:</p>
                    <ul>
                        <li>
                            <code>writable: true | false</code><br>
                            Control de acceso a escritura.
                        </li>
                        <li>
                            <code>value</code><br>
                            Valor por defecto.
                        </li>
                        <li>
                            <code>get: function() { ... }</code><br>
                            Método de acceso.
                        </li>
                        <li>
                            <code>set: function(newValue) { ... }</code><br>
                            Método de modificación.
                        </li>
                        <li>
                            <code>enumerable: true | false</code><br>
                            La propiedad aparecerá en el listado devuelto por <code>Object.keys()</code>.
                        </li>
                    </ul>
                </section>
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 7</span><span style="display:none">:</span><br>Las funciones constructoras y el operador <span style="font-family:monospace; text-transform:none">new</span></h3>
                    </div>
                </section>
                
                <section>
                    <h4>Atributos de funciones</h4>
                    <p>Las funciones de Javascript también son objetos.</p>
                    <p>Esto implica que también pueden contener atributos.</p>
                    <pre><code data-trim class="javascript">
function saludar() {
    console.log("Hola, mundo!");
}

saludar.numeroLineas = 1;
saludar.numeroParametros = 0;
                    </code></pre>
                    <img src="images/03/SaludarFun.svg" style="width:60%;border:none;box-shadow:none">
                </section>
                
                <section>
                    <p>De hecho, las funciones tienen algunos atributos predefinidos:</p>
                    <pre><code data-trim class="javascript">
console.log(saludar.name)   // &rarr; "saludar"
console.log(saludar.length) // &rarr; 0  (nº de argumentos)
                    </code></pre>
                    <p>Entre estos atributos predefinidos existe uno llamado <code>prototype</code>, que inicialmente apunta  un objeto vacío.</p>
                    <pre><code data-trim class="javascript">
console.log(saludar.prototype); // &rarr; { }
                    </code></pre>
                </section>
                
                <section>
                    <p>¡No confundir la propiedad <code>prototype</code> con el prototipo del objeto función!</p>
                    <img src="images/03/SaludarFunPrototype.svg" style="width:90%;border:none;box-shadow:none">
                    <p>El atributo <code>prototype</code> juega un papel esencial en las funciones constructoras.</p>
                </section>
                
                <section>
                    <h4>Funciones constructoras</h4>
                    <p>Una función constructora se encarga de inicializar los atributos del objeto que se encuentra en la variable <code>this</code>.</p>
                    <pre><code data-trim class="javascript">
function Complejo(real, imag) {
    this.r = real;
    this.i = imag;
}
                    </code></pre>
                    <p>Los nombres de las funciones constructoras suelen comenzar con letra mayúscula.</p>
                    <p>Una función constructora es el equivalente a una <em>clase</em> Java.</p>
                </section>
                
                <section>
                    <p>El atributo <code>prototype</code> de las funciones constructoras sirve para almacenar los métodos comunes a la &laquo;clase&raquo;.</p>
                    <pre><code data-trim class="javascript">
Complejo.prototype.modulo = function() {
    return Math.sqrt(this.r * this.r + this.i * this.i);
}

Complejo.prototype.argumento = function() {
    return Math.atan2(this.i, this.r);
}
                    </code></pre>
                </section>
                
                <section>
                    <h4>El operador <code style="text-transform:none">new</code></h4>
                    <p>Se puede invocar a una constructora utilizando el operador <code>new</code>:</p>
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <p>A continuación se describe el funcionamiento de <code>new</code>.</p>
                </section>
                
                <section data-transition="slide-in fade-out">
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <img src="images/03/ComplejoConstructora1.svg" style="width:70%;border:none">
                    <ol style="height:3em; width:90%">
                        
                    </ol>
                </section>

                <section data-transition="fade-in fade-out">
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <img src="images/03/ComplejoConstructora2.svg" style="width:70%;border:none">
                    <ol style="height:3em; width:90%">
                        <li>Se crea un objeto nuevo.</li>
                    </ol>
                </section>

                <section data-transition="fade-in fade-out">
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <img src="images/03/ComplejoConstructora3.svg" style="width:70%;border:none">
                    <ol style="height:3em; width:90%" start="2">
                        <li>El prototipo del nuevo objeto será <code>Complejo.prototype</code>.</li>
                    </ol>
                </section>

                <section data-transition="fade-in fade-out">
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <img src="images/03/ComplejoConstructora4.svg" style="width:70%;border:none">
                    <ol style="height:3em; width:90%" start="3">
                        <li>Se llama a la función constructora <code>Complejo</code> utilizando el nuevo objeto como <code>this</code>.</li>
                    </ol>
                </section>

                <section data-transition="fade-in slide-out">
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);                    
                    </code></pre>
                    <img src="images/03/ComplejoConstructora5.svg" style="width:70%;border:none">
                    <ol style="height:3em; width:90%" start="4">
                        <li>Se asigna la variable <code>x</code> el objeto resultante.</li>
                    </ol>
                </section>
                
                <section>
                    <h4>Resultado</h4>
                    <pre><code data-trim class="javascript">
function Complejo(real, imag) {
    this.r = real;
    this.i = imag;
}

Complejo.prototype.modulo = function() {
    return Math.sqrt(this.r * this.r + this.i * this.i);
}

Complejo.prototype.argumento = function() {
    return Math.atan2(this.i, this.r);
}

var x = new Complejo(-3, 0);
console.log(x.modulo());     // &rarr; 3
console.log(x.argumento());  // &rarr; 3.141592653589793
                    </code></pre>
                </section>
                
                <section>
                    <h4>Resumen</h4>
                    <p>La expresión <code>new C(...)</code> se evalúa del siguiente modo:</p>
                    <ol>
                        <li>Se crea un nuevo objeto.</li>
                        <li>Se establece el prototipo del nuevo objeto a <code>C.prototype</code>.</li>
                        <li>Se llama a la función <code>C</code>, utilizando el nuevo objeto como <code>this</code>.</li>
                    </ol>
                </section>
                
                <section>
                    <h4>El operador <code style="text-transform:none">instanceof</code></h4>
                    <p>La expresión <code>x instanceof C</code> se evalúa a <code>true</code> si el objeto <code>C.prototype</code> es alcanzable siguiendo ascendiendo desde <code>x</code> en la cadena de prototipos:</p>
                    <pre><code data-trim class="javascript">
var x = new Complejo(-3, 0);

console.log(x instanceof Complejo); // &rarr; true
console.log(x instanceof Object);   // &rarr; true
console.log(x instanceof Number);   // &rarr; false
                    </code></pre>
                </section>
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 8</span><span style="display:none">:</span><br>Los arrays tienen poco de arrays, y mucho de objetos</h3>
                    </div>
                </section>
                
                <section>
                    <h4>Inicialización de arrays</h4>
                    <p>
                        Un array puede inicializarse enumerando sus elementos:
                    </p>
                    <pre><code data-trim class="javascript">
var a = [23, 12, 69, 11, 34, 45];
                    </code></pre>
                    <p>o bien mediante el constructor <code>Array</code>:</p>
                    <pre><code data-trim class="javascript">
var b = new Array(10);
// Todos los elementos están a 'undefined'
                    </code></pre>
                </section>
                
                <section>
                    <h4>Los arrays son objetos</h4>
                    <p>Es posible asignar propiedades arbitrarias a un array.</p>
                    <pre><code data-trim class="javascript">
var a = [23, 12, 69, 11, 34, 45];
a.estaOrdenado = false;

console.log(a);
    // &rarr; [ 1, 5, 3, 5, 4, esta_ordenado: false ]
                    </code></pre>
                    
                    <p>Todos los arrays tienen como prototipo el objeto <code>Array.prototype</code>, que contiene algunos métodos de utilidad sobre arrays. <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/prototype">[+]</a></p>
                </section>
                
                <section>
                    <h4>Los arrays son flexibles y pueden tener &laquo;huecos&raquo;</h4>
                    <p>Puede variarse la longitud de un array en tiempo de ejecución. Basta con modificar la propiedad <code>length</code>:</p>
                    <pre><code data-trim class="javascript">
var a = [23, 12, 69, 11, 34, 45];
a.length += 2;  // Ampliamos el array

console.log(a); // &rarr; [ 23, 12, 69, 11, 34, 45, ,  ]

a.length = 3;  // Reducimos el array

console.log(a); // &rarr; [ 23, 12, 69 ]
                    </code></pre>
                    <p>También se puede ampliar el array añadiendo elementos fuera de rango:</p>
                    <pre><code data-trim class="javascript">
a[5] = 32;
console.log(a); // &rarr; [ 23, 12, 69, , , 32 ]
                    </code></pre>
                </section>
                
                <section>
                    <p>Métodos para modificar el tamaño del array:</p>
                    <ul>
                        <li>
                            <code>push(x)</code><br>
                            Inserta <code>x</code> al final del array.
                        </li>
                        <li>
                            <code>pop()</code><br>
                            Elimina y devuelve el último elemento del array.
                        </li>
                        <li>
                            <code>unshift(x)</code><br>
                            Añade <code>x</code> al principio del array, desplazando los restantes elementos.
                        </li>
                        <li>
                            <code>shift()</code><br>
                            Elimina el primer elemento del array, desplazando los restantes elementos.
                        </li>
                        <li>
                            <code>splice(ini, num)</code>
                            Partiendo del elemento en la posición <code>ini</code>, elimina <code>num</code> elementos.
                        </li>
                    </ul>
                </section>
                
                <section>
                    <p>Ejemplo:</p>
                    <pre><code data-trim class="javascript">
var a = [1, 2, 3, 4, 5];
    // a = [1, 2, 3, 4, 5];

a.push(8);
    // a = [1, 2, 3, 4, 5, 8];

a.unshift(-4);
    // a = [-4, 1, 2, 3, 4, 5, 8];

a.pop(); // &rarr; 8
    // a = [-4, 1, 2, 3, 4, 5];

a.shift(); // &rarr; -4
    // a = [1, 2, 3, 4, 5];

a.splice(2, 2); // &rarr; [3, 4]
    // a = [1, 2, 5];
                    </code></pre>
                </section>
                
                <section>
                    <p>Otras operaciones destructivas:</p>
                    <pre><code data-trim class="javascript">
a = [4, 7, 4, 1, 3, 5];
a.sort();
    // a = [1, 3, 4, 4, 5, 7]
    
a.reverse();
    // a = [7, 5, 4, 4, 3, 1]
                    </code></pre>
                </section>
                
                <section>
                    <p>Operaciones no destructivas:</p>
                    <ul>
                        <li>
                            <code>concat(arr_1, ..., arr_n)</code><br>
                            Añade los arrays pasados como argumento y devuelve el resultado.
                            <pre><code data-trim class="javascript">
[1, 2, 3].concat([4, 5], [6, 7, 8]);
    // &rarr; [1, 2, 3, 4, 5, 6, 7, 8]

                            </code></pre>
                        </li>
                        <li>
                            <code>slice(ini, fin)</code><br>
                            Devuelve el segmento <code>[ini, fin)</code> del array.
                            <pre><code data-trim class="javascript">
["a", "b", "c", "d", "e", "f", "g"].slice(2, 5);
    // &rarr; ["c", "d", "e"]
                            </code></pre>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <ul>
                        <li>
                            <code>join(sep)</code><br>
                            Concatena los elementos del array intercalando
                            <code>sep</code> como separador:
                            <pre><code data-trim class="javascript">
["Esto", "no", "me", "gusta"].join(" - ");
    // &rarr; "Esto - no - me - gusta"
                            </code></pre>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <p>Búsqueda de valores:</p>
                    <ul>
                        <li><code>indexOf(elem, [pos_inicial])</code>
                            <p>Devuelve el índice de la última aparición de <code>elem</code> en el array, o -1 si no se encuentra.</p>
                        </li>
                        <li><code>lastIndexOf(elem)</code>
                            <p>Devuelve el índice de la última aparición de <code>elem</code> en el array, o  -1 si no se encuentra.</p>
                        </li>
                    </ul>
                </section>
                
            </section>
            
            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 9</span><span style="display:none">:</span><br>Las funciones de orden superior sobre arrays</h3>
                    </div>
                </section>
                
                <section>
                    <h4>Funciones de orden superior</h4>
                    <p>Una función de <strong>orden superior</strong> es una función que recibe funciones como parámetro y/o devuelve funciones.</p>
                    <p>Javascript proporciona varios métodos de orden superior para arrays que son muy útiles en la práctica.</p>
                </section>
                
                <section>
                    <h4>Iteración: método <code style="text-transform:none">forEach</code></h4>
                    <ul>
                        <li>
                            <code>forEach(f)</code><br>
                            Aplica la función <code>f</code> sobre todos los elementos del array.
                        </li>
                        <pre><code data-trim class="javascript">
var personas = [ { nombre: "Ricardo", edad: 45}, 
                 { nombre: "Julia", edad: 24 }, 
                 { nombre: "Ashley", edad: 28 } ];

personas.forEach(function(p) {
    console.log("Hola, me llamo " + p.nombre 
                + " y tengo " + p.edad + " años");
})                 
                        
                        </code></pre>
                    </ul>
                </section>
                
                
                <section>
                    <h4>Funciones de transformación</h4>
                    <ul>
                        <li>
                            <code>map(f)</code><br>
                            Aplica la función <code>f</code> a cada elemento del array, devolviendo otro array con los resultados.
                            <pre><code data-trim class="javascript">
var a = [1, 3, 5, 2, 4];
var dobles = a.map(function(n) {
    return n * 2;
});
console.log(dobles); // [2, 6, 10, 4, 8]
                            </code></pre>
                        </li>
                        <li>
                            <code>filter(f)</code><br>
                            Selecciona los elementos <code>x</code> del array tales que <code>f(x)</code> devuelve <code>true</code>.
                            <pre><code data-trim class="javascript">
var pares = a.filter(function(n) {
    return n % 2 === 0;
});
console.log(pares); // [2, 4]
                            </code></pre>
                        </li>
                    </ul>
                    
                </section>
                
                <section>
                    <h4>Funciones de reducción (I)</h4>
                    <ul>
                        <li>
                            <code>every(f)</code><br>
                            Devuelve <code>true</code> si para <em>todo</em> elemento <code>x</code> del array, <code>f(x)</code> devuelve <code>true</code>.
                        </li>
                        <li>
                            <code>some(f)</code><br>
                            Devuelve <code>true</code> si <em>existe</em> un elemento <code>x</code> en el array tal que <code>f(x)</code> devuelva <code>true</code>.
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Funciones de reducción (II)</h4>
                    <ul>
                        <li>
                            <code>reduce(f, [elemInicial])</code><br>
                            Recorre el array de izquierda a derecha, acumulando un valor durante el recorrido.
                        </li>
                        <pre><code data-trim class="javascript">
var a = [2, 6, 9, 1];

console.log(
    "Valor final: " +
    a.reduce(function(acum, n) { return 2 * acum +  n; }, 7)
);  // &rarr; 171
    
                        </code></pre>
                    </ul>
                </section>
                
                <section>
                    <p><img src="images/03/Reduce1.svg" style="width:100%; border:none; box-shadow:none"></p>
                </section>
            
            </section>
            

        </div>

    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            history: true,

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [{
                src: 'plugin/markdown/marked.js'
            }, {
                src: 'plugin/markdown/markdown.js'
            }, {
                src: 'plugin/notes/notes.js',
                async: true
            }, {
                src: 'plugin/highlight/highlight.js',
                async: true,
                callback: function() {
                    hljs.initHighlightingOnLoad();
                }
            }]
        });
    </script>
</body>

</html>
