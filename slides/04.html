<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tema 4 - Node.js</title>


    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/aw.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/magula.css">


    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <link rel="stylesheet" href="css/traspas.css" />
</head>

<body>
    <svg width="0" height="0" style="float:left">
        <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto" markerUnits="strokeWidth" style="display:float">
                <path d="M0,0 L0,6 L9,3 z" fill="#000" />
            </marker>
        </defs>
    </svg>
    <div class="reveal">
        <div class="slides">
            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade">
                <div class="headerlesson">Tema 4</div>
                <h1 style="height:3em;position:relative;top:0.3em">Javascript en el servidor: Node.js</h1>
                <div class="headerlesson">
                    Aplicaciones Web - GIS - Curso 2016/17
                </div>
                <div class="author">
                    <span class="myname">Manuel Montenegro</span> [<a href="mailto:montenegro@fdi.ucm.es" style="color:white">montenegro@fdi.ucm.es</a>]
                    <br/> Dpto de Sistemas Informáticos y Computación
                    <br/> Facultad de Informática
                    <br/> Universidad Complutense de Madrid
                </div>
                <div class="cc">
                    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                    <br/> Esta obra está bajo una
                    <br/><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:white">Licencia CC BY-NC-SA 4.0 Internacional</a>.
                </div>
                <div style="clear:left;font-size:15px"></div>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade" id="p1">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline fragment highlight-orange">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p6" class="outline">ECMAscript 6</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>Introducción</h2>
                <p>Node.js (o simplemente Node) es un entorno de ejecución que permite ejecutar programas <strong>Javascript</strong>.</p>
                <p><a href="https://nodejs.org/">https://nodejs.org/</a></p>
                <p>Principalmente dirigido a servidores web, pero puede utilizarse para implementar cualquier tipo de aplicación.</p>
                <p>En este curso utilizaremos Node para implementar la funcionalidad del <strong>lado del servidor</strong> en las aplicaciones web.</p>
                <p>Se distribuye bajo una <a href="https://es.wikipedia.org/wiki/Licencia_MIT">licencia MIT</a>.</p>
            </section>
            
            <section>
                <h3>Versiones</h3>
                <ul>
                    <li><strong>v4.6.1 LTS</strong>, que utilizaremos en este curso.</li>
                    <li><strong>v6.9.1 LTS</strong>, que pasó a ser LTS en octubre de 2016.</li>
                </ul>
                <p>LTS = <em>Long Term Support</em></p>
                <p>Las versiones LTS tienen suporte garantizado durante 18 meses a partir del momento en el que se convierten en LTS.</p>
                <p>Las versiones 6.x.x rompen la compatibilidad con las 4.x.x. Algunos programas escritos en Node 4 pueden requerir modificaciones para ejecutarse bajo Node 6.</p>
            </section>
            
            <section>
                <h3>Instalación</h3>
                <p>Puede descargarse desde:</p>
                <p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
                <p>En las versiones para Windows y Mac incluye un instalador.</p>
                <p>Desde GNU/Linux se puede:</p>
                <ul>
                    <li>Descargar los binarios desde la página anterior.</li>
                    <li>Utilizar el gestor de paquetes de la distribución.</li>
                    <li>Utilizar <strong>nvm</strong> (<a href="http://nvm.sh">http://nvm.sh</a>), que permite mantener varias versiones de Node en un mismo sistema.</li>
                </ul>
            </section>
            
            <section>
                <h3>Ejecución de un script</h3>
                <p>Basta con teclear:</p>
                <pre><code data-trim data-noescape class="no-highlight">
# node <em>nombre_script.js</em>
                </code></pre>
                <p>Si se desea ejecutar el intérprete (REPL):</p>
                <pre><code data-trim data-noescape class="no-highlight">
# node
                </code></pre>
                <p>REPL = <em>Read-Eval-Print Loop</em></p>
                <p>El intérprete permite evaluar las expresiones Node que se introduzcan por teclado.</p>
            </section>
            
            <section>
                <h4>Ejemplo de sesión con el intérprete</h4>
                <pre><code data-trim data-noescape class="no-highlight">
# <span class="hl">node</span>
> <span style="color:#720">5 + 6</span>
11
> <span style="color:#720">var x = 4 + 5</span>
undefined
> <span style="color:#720">console.log("Hola");</span>
Hola
undefined
> <span style="color:#720">x</span>
9
> <span style="color:#720">function suma(x,y) {</span>
..... <span style="color:#720">return x + y;</span>
..... <span style="color:#720">}</span>
undefined
> <span style="color:#720">suma(4, 5)</span>
9
> <span style="color:#720">.exit</span>
                </code></pre>
            </section>
            
            <section>
                <h4>Comandos del intérprete</h4>
                <ul>
                    <li>
                        <code>.exit</code><br>
                        Sale del intérprete.
                    </li>
                    <li>
                        <code>.load <em>script.js</em></code><br>
                        Ejecuta las sentencias del fichero dado.
                    </li>
                    <li>
                        <code>.save <em>script.js</em></code><br>
                        Guarda todas las expresiones evaluadas en un fichero.
                    </li>
                    <li>
                        <code>.break</code><br>
                        Cancelar introducción de expresión actual. Útil cuando se queda algún paréntesis abierto en la entrada.
                    </li>
                </ul>
            </section>
            
            <section>
                <h3>Proyectos Node</h3>
                <p>
                   La gestión de proyectos de cierta envergadura utilizando el ejecutable <code>node</code> resulta algo tediosa, porque involucra:
                </p>
                <ul>
                    <li>Gestión de dependencias (librerías externas).</li>
                    <li>Arranque y parada del sistema.</li>
                    <li>etc.</li>
                </ul>
                <p>Podemos gestionar los proyectos:</p>
                <ul>
                    <li>Desde la línea de comandos: <code>npm</code>.</li>
                    <li>Desde un IDE: <em>Netbeans</em>.</li>
                </ul>
            </section>
            
            <section>
                <h3>NPM (Node Package Manager)</h3>
                <p>
                    Es una herramienta que se incluye con la distribución de Node. Permite:
                </p>
                <ul>
                    <li>Crear proyectos vacíos.</li>
                    <li>Gestionar las librerías de las que hace uso un proyecto, bajándoselas desde un repositorio oficial (<a href="https://registry.npmjs.org/">NPM Registry</a>).</li>
                    <li>Gestionar <em>scripts</em>: arranque del sistema, parada, ejecución de tests, etc.</li>
                </ul>
                <p>
                    Más información: <a href="https://www.npmjs.com/">https://www.npmjs.com/</a>
                </p>
            </section>
            
            <section>
                <h3>Creación de un proyecto con <code>npm</code>:</h3>
                <p>Ejecutar desde la línea de comandos:</p>
                <pre><code data-trim class="no-highlight">
# npm init
                </code></pre>
                <p>Se solicitará información sobre los datos del proyecto:</p>
                <pre><code data-trim data-noescape class="no-highlight">
...

name: (project-test) <span class="hl" style="color:#20A">miproyecto</span>
version: (1.0.0) <span class="hl" style="color:#20A">&#x21b2; (Pulsar intro)</span>
description: <span class="hl" style="color:#20A">Esto es un proyecto de prueba</span>
entry point: (index.js) <span class="hl" style="color:#20A">app.js</span>
test command: <span class="hl" style="color:#20A">&#x21b2;</span>
git repository: <span class="hl" style="color:#20A">&#x21b2;</span>
keywords: <span class="hl" style="color:#20A">node proyecto aw prueba</span>
author: <span class="hl" style="color:#20A">Manuel Montenegro</span>
license: (ISC) <span class="hl" style="color:#20A">MIT</span>
About to write to /home/manuel/Docencia/AW/Pruebas/project-test
/package.json:
...
Is this ok? (yes) <span class="hl" style="color:#20A">yes</span>

                </code></pre>
            </section>
            
            <section>
                <p>Se creará un fichero <code>package.json</code> con el siguiente contenido:</p>
                <pre><code data-trim class="json">
{
  "name": "miproyecto",
  "version": "1.0.0",
  "description": "Esto es un proyecto de prueba",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "node",
    "proyecto",
    "aw",
    "prueba"
  ],
  "author": "Manuel Montenegro",
  "license": "MIT"
}
                </code></pre>
            </section>
            
            <section>
                <ul>
                    <li>
                    Atributo <code>scripts</code>: permite añadir comandos para arrancar el programa, detenerlo, etc.<br>
                    Por ejemplo, podemos añadir:
                        <pre><code data-trim data-noescape class="json">
...
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"<span class="hl">,</span>
    <span class="hl">"start": "node app.js"</span>
  }, 
...
                        </code></pre>
                        para poder arrancar el sistema mediante
                        <pre><code data-trim class="no-highlight">
# npm start                        
                        </code></pre>
                    </li>
                </ul>
            </section>
            
            <section>
                <p>Si no se introduce un nombre para repositorio Git, es posible declarar el paquete como privado, mediante la opción <code>private</code>:</p>
                <pre><code data-trim data-noescape class="json">
{ 
  ...
  "author": "Manuel Montenegro",
  "license": "MIT",
  <span class="hl">"private": true</span>
}
                </code></pre>
                <p>De este modo evitaremos <em>warnings</em> sobre la ausencia de un repositorio.</p>
            </section>
            
            <section>
                <h3>Uso de Netbeans</h3>
                <p>Netbeans dispone un <em>plugin</em> para Node.</p>
                <p>Se requiere Netbeans 8.1 o posterior.</p>
                <p>Al descargarlo de la página web <a href="https://netbeans.org">https://netbeans.org</a> es necesario seleccionar la versión <em>HTML5/Javascript</em> o <em>All</em>.</p>
            </section>
            
            <section>
                <img src="images/04/NetbeansDownload.png" style="width:80%">
            </section>
            
            
            <section>
                <h4>Configuración de Netbeans</h4>
                <p>Antes de utilizar el <em>plugin</em> de Netbeans es necesario indicar el directorio en el que se encuentran los ejecutables de Node: <code>node</code>, <code>npm</code>, etc. </p>
                <p>Menú <em>Tools</em> &rarr; <em>Options</em> &rarr; Pestaña <em>HTML/JS</em> &rarr; Pestaña <em>Node</em></p>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/CSh2Whhcnms" frameborder="0" allowfullscreen></iframe>
            </section>
            
            <section>
                <img src="images/04/NetbeansOptions.png" style="width:90%">
            </section>
            
            <section>
                <h4>Crear un proyecto en Netbeans</h4>
                <p><em>File</em> &rarr; <em>New Project...</em></p>
                <p>Seleccionar categoría <em>HTML5/Javascript</em> y tipo de aplicación <em>Node.js application</em>.</p>
                <img src="images/04/NewProject.png" style="width:60%"> 
            </section>
            
            <section>
                <p>Especificar nombre de proyecto y pulsar <em>Next &gt;</em></p>
                <img src="images/04/ProjectName.png" style="width:80%">
            </section>
            
            <section>
                <p>Aceptar opciones por defecto y pulsar <em>Finish</em></p>
                <img src="images/04/ProjectOptions.png" style="width:80%">
            </section>
            
            <section>
                <h2>Módulos en Node</h2>
                <p>Además de poder dividir el código en fragmentos, favorecen la reutilización de código.</p>
                <p>Un buen sistema de módulos debe proporcionar:</p>
                <ul>
                    <li>Algún mecanismo para <strong>evitar conflictos de nombres</strong> entre distintos módulos.
                        <p style="color:#009893">Ejemplo: Espacios de nombres (C++), paquetes (Java), etc.</p>
                    </li>
                    <li>
                        Mecanismos para <strong>separar interfaz de implementación</strong>.
                        <p style="color:#009893">Ejemplo: listas de funciones exportadas (Haskell), privacidad de atributos (Java, C++, etc).</p>
                    </li>
                </ul>
            </section>
            
            
            
            
            <section>
                <h3>Tipos de módulos</h3>
                <ol>
                    <li>Módulos <strong>basados en ficheros</strong>.<br>
                        Están contenidos en un único fichero. Se importan por separado en el proyecto.
                    </li>
                    <li>Módulos <strong>core</strong>.<br>
                        Vienen incluidos con Node. Proporcionan operaciones básicas (ficheros, servidores web, sistema operativo).
                    </li>
                    <li>Módulos de tipo <strong>paquete</strong>.<br>
                        Librerías externas, gestionadas por <em>npm</em>.
                    </li>
                    
                </ol>
                
            </section>
            
            <section>
                <h3>Crear un módulo de fichero con una única función</h3>
                <p>Se crea un fichero Javascript con la función a definir y ésta se asigna a la variable <code>module.exports</code>:</p>
                <pre><code data-trim data-noescape class="javascript">
function fibAux(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fib(n-1) + fib(n-2);
    }
}

function fib(n) {
    console.assert(typeof(n) === "number", `${n} is not a number`);
    return fibAux(n);
}

<span class="hl">module.exports = fib;</span>
                </code></pre>
            </section>
            
            <section>
                <p>Suponemos que el código anterior está contenido en un fichero <code>moduloFib.hs</code>.</p>
                <p>Ahora hacemos uso de la función <code>fib</code> desde otro fichero:</p>
                <pre><code data-trim data-noescape class="javascript">
// testModules.js
// --------------

var fib = require("./moduloFib.js");

console.log(fib(10));                
                </code></pre>
                <p>Imprime:</p>
                <pre>55</pre>
            </section>
            
            <section>
                <div style="background-color:#B0F0B0; padding:10px 10px 25px  15px">
                    <p>La función <code>require</code>:</p>
                    <ol>
                        <li>Ejecuta el script contenido en el fichero pasado como parámetro.</li>
                        <li>Devuelve el objeto asignado a <code>module.exports</code> (en este caso, la función <code>fib</code>)</li>
                    </ol>
                </div>
            </section>
            
            <section>
                <p>El objeto devuelto por <code>require</code> se guarda en una variable que no tiene por qué ser igual que el nombre de la función exportada.</p>
                <pre><code data-trim data-noescape class="javascript">
var <span class="hl">myFib</span> = require("./moduloFib.js");

console.log(<span class="hl">myFib</span>(10));                
                </code></pre>
                <p>Esto es útil para prevenir conflictos de nombres entre los distintos módulos. Supongamos otro módulo <code>otroModuloFib.hs</code> que también exporta una función <code>fib</code>:</p>
                <pre><code data-trim data-noescape class="javascript">
var <span class="hl">myFib</span> = require("./moduloFib.js");
var <span class="hl">otroFib</span> = require("./otroModuloFib.js");

console.log(myFib(10));
console.log(otroFib(10));
                </code></pre>
                
            </section>
            
            <section>
                <h3>Exportar más de una función</h3>
                <p>
                    Hasta ahora hemos asignado una función a la variable <code>module.exports</code>.
                </p>
                <p>Pero puede asignarse cualquier otro tipo de valor: enteros, arrays, objetos, etc.</p>
                <p>Lo más frecuente es querer exportar varias funciones en un módulo. Para ello se exporta un único <strong>objeto</strong> que contenga todas las funciones. </p>
            </section>
            
            <section>
                <p>Ejemplo: <code>geometria.js</code></p>
                <pre><code data-trim class="javascript">
function areaCuadrado(lado) {
    return lado * lado;
}

function areaCirculo(radio) {
    return Math.PI * radio * radio;
}

function perimetroCuadrado(lado) {
    return 4 * lado;
}

function perimetroCirculo(radio) {
    return 2 * Math.PI * radio;
}

module.exports = {
    areaCuadrado: areaCuadrado,
    areaCirculo: areaCirculo,
    perimetroCuadrado: perimetroCuadrado,
    perimetroCirculo: perimetroCirculo
}                
                </code></pre>
            </section>
            
            <section>
                <pre><code data-trim class="javascript">
...
module.exports = {
    areaCuadrado: areaCuadrado,
    areaCirculo: areaCirculo,
    perimetroCuadrado: perimetroCuadrado,
    perimetroCirculo: perimetroCirculo
}                
                </code></pre>
                <p>El objeto exportado contiene cuatro atributos, cada uno asociado a su función correspondiente.</p>
                <p>Los nombres de estos atributos serán los que se utilicen cuando se haga uso de este módulo.</p>
            </section>
            
            <section>
                <p>Ejemplo de uso:</p>
                <pre><code data-trim data-noescape class="javascript">
var <span class="hl">geometria</span> = require("./geometria.js");

console.log(<span class="hl">geometria</span>.areaCuadrado(10));
console.log(<span class="hl">geometria</span>.areaCirculo(10));                
                </code></pre>
                
                <p>De nuevo, el nombre de la variable devuelta por el <code>require</code> puede ser cualquiera:</p>
                <pre><code data-trim data-noescape class="javascript">
var <span class="hl">g</span> = require("./geometria.js");

console.log(<span class="hl">g</span>.areaCuadrado(10));
console.log(<span class="hl">g</span>.areaCirculo(10));             
                </code></pre>
            <p>Aunque por convenio suele utilizarse el mismo nombre para la variable y el módulo (es decir, <code>geometria</code>)</p>
            </section>
            
            <section>
                <p>Otra posible forma de definir un módulo: definir las funciones en el objeto asignado a <code>module.exports</code>.</p>
                <pre><code data-trim class="javascript">
module.exports = {
    areaCuadrado: function(lado) {
        return lado * lado;
    },

    areaCirculo: function(radio) {
        return Math.PI * radio * radio;
    },

    perimetroCuadrado: function(lado) {
        return 4 * lado;
    },
    
    perimetroCirculo: function(radio) {
        return 2 * Math.PI * radio;
    }
}                
                </code></pre>
            </section>
            
            <section>
                <p>Otra forma más:</p>
                <pre><code data-trim class="javascript">
module.exports.areaCuadrado = function(lado) {
    return lado * lado;
};

module.exports.areaCirculo = function(radio) {
    return Math.PI * radio * radio;
};

module.exports.perimetroCuadrado = function(lado) {
    return 4 * lado;
};

module.exports.perimetroCirculo = function(radio) {
    return 2 * Math.PI * radio;
};                
                </code></pre>
            </section>
            
            <section>
                <p>Lo que no se exporte dentro de un módulo se considera privado al mismo. Esto nos permite modificar la implementación sin alterar la interfaz.</p>
                <pre><code data-trim class="javascript">
// moduloFib.js
// ------------

var PHI = (1 + Math.sqrt(5)) / 2;

// Cambio la función fibAux por esta:
function fibMasEficiente(n) {
    var p1 = Math.pow(PHI, n);
    var p2 = Math.pow(1 - PHI, n);
    return Math.round((p1 - p2) / Math.sqrt(5));
}

function fib(n) {
    console.assert(typeof(n) === "number",
        `fib: ${n} is not a number`);
    return fibMasEficiente(n);
}

module.exports = fib;                
                </code></pre>
            </section>
            
            <section>
                <h3>Importante</h3>
                <p>A la hora de importar un módulo de tipo fichero mediante <code>require</code>, es necesario indicar el <strong>path</strong> del fichero que se importa,  <strong>aunque se encuentre en el mismo directorio</strong>.</p>
                <pre><code data-trim data-noescape class="javascript">
// Correcto:
var geometria = require("<span class="hl">./</span>geometria.js");

// Correcto:
var geometria = require("<span class="hl">./aw/librerias/</span>geometria.js");

// Correcto:
var geometria = require("<span class="hl">../</span>geometria.js");

// Incorrecto:
var geometria = require("<span class="hl" style="background-color:#FBB">geometria.js</span>");
                </code></pre>
                
                <p>No obstante, puede omitirse la extensión <code>.js</code></p>
                <pre><code data-trim class="javascript">
// Correcto:
var geometria = require("./geometria");
                </code></pre>
            </section>
            
            <section>
                <pre><code data-trim data-noescape class="javascript">
// Incorrecto:
var geometria = require("<span class="hl" style="background-color:#FBB">geometria.js</span>");                
                </code></pre>
                <p>Si no se especifica un <em>path</em>, Node entiende que se quiere importar un módulo de otro tipo:</p>
                <ul>
                    <li>Módulo core.</li>
                    <li>Módulo de tipo paquete.</li>
                </ul>
            </section>
            
            <section>
                <h3>Sentencias en un módulo</h3>
                <p>Además de declaraciones de funciones, un módulo puede contener cualquier tipo de sentencia. Estas sentencias serán ejecutadas al cargar el módulo.</p>
                <pre><code data-trim data-noescape class="javascript">
<span class="hl">console.log("Cargando módulo " + module.filename);</span>

function areaCuadrado(lado) { ... }

function areaCirculo(radio) { ... }

function perimetroCuadrado(lado) { ... }

function perimetroCirculo(radio) { ... }

module.exports = {
    areaCuadrado: areaCuadrado,
    areaCirculo: areaCirculo,
    perimetroCuadrado: perimetroCuadrado,
    perimetroCirculo: perimetroCirculo
}                
                </code></pre>
            </section>
            
            
            <section>
                <h3>El objeto <code style="text-transform:none">module</code></h4>
                <p>Contiene información sobre el módulo que se está ejecutando actualmente <a href="https://nodejs.org/api/modules.html#modules_the_module_object">[+]</a></p>
                
                <p>La variable especial <code>require.main</code> contiene el nombre del módulo que se ha cargado desde el intéprete de línea de comandos.</p>
                <p>Esto nos permite saber si un módulo está siendo ejecutado directamente por Node, o si está siendo importado desde otro módulo.</p>
            </section>
            
            <section>
                <p>Ejemplo: <code>moduloFib.js</code></p>
                <pre><code data-trim class="javascript">
// ...
function fib(n) {
    // ...
}

module.exports = fib;

if (require.main === module) {
    console.log("Sucesión de Fibonacci");
    for (var i = 0; i &lt; 10; i++) {
        console.log(`fib(i) = ${fib(i)}`);
    }
}                
                </code></pre>
            </section>
            
            <section>
                <p>Al ejecutarlo desde la línea de comandos:</p>
                <pre><code data-trim data-noescape class="no-highlight">
# <span class="hl">node moduloFib.js</span>
Sucesión de Fibonacci
fib(i) = 0
fib(i) = 1
fib(i) = 1
fib(i) = 2
fib(i) = 3
fib(i) = 5
fib(i) = 8
fib(i) = 13
fib(i) = 21
fib(i) = 34
                </code></pre>
                
                <p>Al importarlo desde otro módulo:</p>
                <pre><code data-trim class="javascript">
var fib = require("./moduloFib"); // No imprime nada
                </code></pre>
            </section>
            
            <section>
                <h3>Los módulos se &laquo;cachean&raquo;</h3>
                <p>Cuando un módulo se importa varias veces mediante <code>require</code> a lo largo de la ejecución de un programa, el módulo cargado solo se ejecuta la primera vez.</p>
                <p>El resto de veces, <code>require</code> no vuelve a ejecutar el módulo. Se limita devuelve el contenido del <code>module.exports</code> que se definió en el módulo la primera vez que se cargó.</p>
                <p>En el ejemplo <code>geometria.js</code>:</p>
                <pre><code data-trim class="javascript">
var g1 = require("./geometria");
// Imprime: "Cargando módulo geometría.js"

...
var g2 = require("./geometria");
// No se imprime nada, porque el módulo ha sido cargado
                </code></pre>
            </section>
            
            <section>
                <p>¡Cuidado con las variables globales en el módulo!</p>
                <pre><code data-trim class="javascript">
// bd.js
// -----
var bd = {
    "50382322X" : { nombre: "Francisco Martín", 
                    fecha: new Date(1978, 04, 04) },
    "46854322V" : { nombre: "Estela Lucas",
                    fecha: new Date(1979, 03, 15) }
};

function obtenerPersona(dni) { return bd[dni]; }

function numeroPersonas() {
    return Object.getOwnPropertyNames(bd).length;
}

function añadirPersona(dni, nomb, fechaNac) {
    bd[dni] = { nombre: nomb, fecha: fechaNac };
}

module.exports = {
    obtenerPersona: obtenerPersona,
    numeroPersonas: numeroPersonas,
    añadirPersona: añadirPersona
};
                </code></pre>
                
            </section>
            
            <section>
                <pre><code data-trim class="javascript">
// En un punto del programa:

var bd1 = require("./bd");
bd1.añadirPersona("11111111V", "Fátima", new Date());
console.log(bd1.numeroPersonas());  // &rarr; 3

// ...

// En otro punto del programa:

var bd2 = require("./bd");
console.log(bd2.numeroPersonas());  // &rarr; 3   
                </code></pre>
                
                <p>Tanto <code>bd1</code> como <code>bd2</code> hacen referencia a la misma base de datos, ya que al hacer <code>require</code> por segunda vez se reutiliza el mismo módulo que se cargó la primera vez.</p>
            </section>
            
            <section>
                <h3>Módulos Core</h3>
                <p>Forman parte de la distribución de Node.</p>
                <p>También se importan mediante <code>require</code>, pero sin indicar un path relativo.</p>
                <pre><code data-trim class="javascript">
var os = require("os");
console.log(`Nombre del host: ${os.hostname()}`);
console.log(`Directorio personal: ${os.homedir()}`);

var util = require("util");
var mensaje = util.format("Tienes %d años", 45);
                </code></pre>
                <p>Nombres de módulos core: <code>os</code>, <code>fs</code>, <code>path</code>, <code>http</code>, <code>util</code>, etc.</p>
            </section>
            
            <section>
                <h3>Módulos de tipo paquete</h3>
                <p>Son módulos pensados para ser reutilizados e incorporados a otros proyectos.</p>
                <p>Están contenidos en una carpeta llamada <code>node_modules</code>.</p>
                <p>Se importan con <code>require</code> y, al igual que los módulos core, no se indica el path relativo.</p>
            </section>
            
            <section>
                <h3>Búsqueda de un módulo de tipo paquete</h3>
                <pre><code data-trim class="javascript">
var foo = require("foo");
                </code></pre>
                <p>Se busca <code>foo</code> en los siguientes directorios:</p>
                <ul>
                    <li><code>node_modules/foo.js</code></li>
                    <li><code>../node_modules/foo.js</code></li>
                    <li><code>../../node_modules/foo.js</code></li>
                    <li><code>../../../node_modules/foo.js</code></li>
                    <li>y así sucesivamente, hasta llegar al directorio raíz</li>
                </ul>
            </section>
            
            <section>
                <p>Por ejemplo, supongamos que en el fichero <code>/home/manuel/aw/ejemplo.js</code><br>buscamos el siguiente paquete:</p>
                <pre><code data-trim class="javascript">
var mimodulo = require("mimodulo");
                </code></pre>
                <p>Se buscará en los siguientes directorios:</p>
                <ul>
                    <li><code>/home/manuel/aw/node_modules/mimodulo.js</code></li>
                    <li><code>/home/manuel/node_modules/mimodulo.js</code></li>
                    <li><code>/home/node_modules/mimodulo.js</code></li>
                    <li><code>/node_modules/mimodulo.js</code></li>
                </ul>
            </section>
            
            <section>
                <h3>Paquetes con varios módulos</h3>
                <p>Un paquete puede contener más de un fichero <code>.js</code></p>
                <p>En este caso han de agruparse todos los <code>.js</code> en la misma carpeta, y guardar en esta carpeta un módulo <code>index.js</code> que exporte las funciones necesarias de cada uno de los módulos del paquete.</p>
                <p>Para importar este paquete mediante <code>require</code> se debe indicar el nombre de la carpeta.</p>
            </section>
            
            <section>
                <p>Partimos de esta estructura de directorios:</p>
                <p><img src="images/04/FolderStructure.svg" style="border:none;width:30%;box-shadow:none"></p>
            </section>

            <section>
                <p style="float:left;width:30%"><img src="images/04/FolderStructure.svg" style="border:none;width:100%;box-shadow:none"></p>
                <div style="width:70%;float:right;">
                    <p><code>fib.js</code></p>
                    <pre><code data-trim class="javascript">
"use strict";

function fib(n) { ... }

module.exports = fib;                    
                    </code></pre>
                    <p><code>fact.js</code></p>
                    <pre><code data-trim class="javascript">
"use strict";

function fact(n) { ... }

module.exports = fact;
                    </code></pre>
                </div>
                <div style="clear:both"></div>
                
            </section>
            
            <section>
                <p style="float:left;width:30%"><img src="images/04/FolderStructure.svg" style="border:none;width:100%;box-shadow:none"></p>
                <div style="width:70%;float:right;">
                    <p><code>index.js</code></p>
                    <pre><code data-trim class="javascript">
"use strict";

module.exports = {
    fib: require("./fib"),
    fact: require("./fact")
}
                    </code></pre>
                </div>
                <div style="clear:both"></div>
                
            </section>

            <section>
                <p style="float:left;width:30%"><img src="images/04/FolderStructure.svg" style="border:none;width:100%;box-shadow:none"></p>
                <div style="width:70%;float:right;">
                    <p><code>ejemplo.js</code></p>
                    <pre><code data-trim data-noescape class="javascript">
"use strict";

<span class="hl">var math = require("math");</span>

console.log(`fib(6) = ${math.fib(6)}`);
console.log(`fact(6) = ${math.fact(6)}`);                    </code></pre>
                </div>
                <p style="clear:both">Resultado:</p>
                <pre><code data-trim data-noescape class="no-highlight">
$ <span class="hl">node ejemplo.js</span>
fib(6) = 8
fact(6) = 720
                </code></pre>
            </section>
            
            <section>
                <h3>Aplicaciones del sistema de paquetes</h3>
                <p>
                    Compartición de paquetes entre proyectos:
                </p>
                <img src="images/04/Subproyectos.svg" style="width:70%; border:none; box-shadow:none">
            </section>
            
            <section>
                <p>Convivencia de distintas versiones de un mismo paquete:</p>
                <img src="images/04/VersionesPaquete.svg" style="width:55%; border:none; box-shadow:none">                
            </section>
            
            <section>
                <h3>Árbol de dependencias</h3>
                <p>A menudo, la implementación de un proyecto Node requiere la instalación de unos determinados paquetes.</p>
                <p>Cada uno de estos últimos pueden requerir la instalación de otros paquetes que, a su vez, requieren de otros paquetes.</p>
                <p>Cuando la presencia del paquete X es un requisito para el funcionamiento del paquete Y, decimos que <strong>Y depende de X</strong>.</p>
                <p>La relación de dependencia entre paquetes es transitiva, de modo que se tiene un <strong>árbol de dependencias</strong>.</p>
            </section>
            
            <section>
                <h4>Ejemplo</h4>
                <img src="images/04/Depende.svg" style="width:90%;border:none;box-shadow:none">
            </section>
            
            <section>
                <h3>Instalar dependencias con <code>npm</code></h3>
                <p>La herramienta <code>npm</code> permite gestionar las dependencias de un proyecto. De hecho, <code>npm</code> fue inicialmente concebido como un instalador de paquetes.</p>
                <p>Esta herramienta puede descargar paquetes desde un depósito de paquetes, e incorporarlos en nuestro proyecto. <a href="">http://foo.com</a></p>
            </section>
            
            <section>
                <p>Para descargar e instalar un paquete en un proyecto, ejecutar lo siguiente desde el directorio raíz del mismo.</p>
                <pre><code data-trim data-noescape class="no-highlight">
# npm install <em>nombre_paquete</em> 
                </code></pre>
                <p>Por ejemplo, para incorporar el paquete <code>underscore</code> en nuestro proyecto:</p>
                <pre><code data-trim class="no-highlight">
# npm install underscore
                </code></pre>
                <p>Descargará la versión más reciente del paquete desde el depósito <code>npm</code> y lo instalará bajo la carpeta <code>node_modules</code> del proyecto (creándola si es necesario)</p>
            </section>

            <section>
                <p>El comando <code>npm install</code> no solo instala el paquete especificado, sino también sus dependencias.</p>
                <p>Por ejemplo al instalar <code>express</code>:</p>
                <pre><code data-trim data-noescape class="no-highlight">
# npm install express
                </code></pre>
                <p>Se instala el paquete <code>express</code> y todo su árbol de dependencias bajo la carpeta <code>node_modules</code>:</p>
                <pre><code data-trim class="no-highlight" style="background:#F0F0F0;color:blue">
node_modules
├── express
├── accepts
├── array-flatten
├── content-disposition
├── content-type
├── cookie
...                
                </code></pre>
            </section>
            
            <section>
                <h4>Incluir dependencias en <code>package.json</code></h4>
                <p>El fichero <code>package.json</code> de un proyecto permite especificar las dependencias del mismo mediante la propiedad <code>dependencies</code>:</p>
                <pre><code data-trim data-noescape class="json">
{
  "name": "mi_proyecto",
  "version": "1.0.0",
  "description": "Prueba de uso de paquetes",
  "main": "main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Manuel Montenegro",
  "license": "ISC",
  "dependencies": {
    <span class="hl">"underscore": "^1.8.3"</span>,
    <span class="hl">"express": "^4.14.0"</span>
  },
  "private": true
}                
                </code></pre>
            </section>
            
            <section>
                <p>Por defecto, <code>npm</code> no modifica el fichero <code>package.json</code> tras añadir un paquete a nuestro proyecto.</p>
                <p>No obstante, al instalar un paquete podemos indicar a <code>npm</code> que añada la dependencia correspondiente a <code>package.json</code>. Esto se hace mediante la opción <code>--save</code>.</p>
                <pre><code data-trim class="no-highlight">
# npm install underscore --save
# npm install express --save
                </code></pre>
            </section>
            
            <section>
                <h4>Instalación global de paquetes</h4>
                <p>Es posible instalar los paquetes en el directorio de Node, en lugar del directorio del proyecto. Los paquetes instalados allí estarán disponibles para todos los proyectos.</p>
                <p>Esto resulta útil cuando un paquete incorpora ficheros ejecutables para ser utilizados en cualquier proyecto del sistema (<code>grunt</code>, <code>jshint</code>, etc.)</p>
                <p>Los paquetes globales se instalan en <code>${prefix}/lib/node_modules</code>, donde <code>${prefix}</code> representa el directorio de instalación de Node. La instalación puede requerir <strong>derechos de administrador</strong>.</p>
            </section>
            
            <section>
                <p>Para instalar un paquete de manera global, se ha de especificar la opción <code>-g</code> a <code>npm</code>.</p>
                <p>Por ejemplo:</p>
                <pre><code data-trim class="no-highlight">
# npm install -g jshint                
                </code></pre>
                <p>Además del paquete correspondiente, instalará el ejecutable <code>jshint</code> en la carpeta <code>${prefix}/bin</code>.</p>
            </section>
            
            <section>
                <h3>Distribución de un proyecto</h3>
                <p>
                    Cuando se quiere distribuir un proyecto o publicar en un repositorio (p.ej. <em>GitHub</em>), <strong>no es necesario</strong> incluir las dependencias obtenidas mediante <code>npm</code>.
                </p>
                <p>
                    Basta con indicar las dependencias en el <code>package.json</code>, y distribuir este último junto con el proyecto.
                </p>
                <p>Mediante el comando:</p>
                <pre><code data-trim class="no-highlight">
# npm install
                </code></pre>
                <p>se reconstruirá la carpeta <code>node_modules</code> a partir de la información contenida en <code>package.json</code>, descargando los paquetes que sean necesarios.</p>
            </section>
            
            <section>
                <h3>Otras opciones de <code>npm</code></h3>
                <ul>
                    <li>
                        <code>npm ls</code><br>
                        Muestra el árbol de dependencias del proyecto actual.
                    </li>
                    <li>
                        <code>npm search <em>term</em></code><br>
                        Busca los paquetes del repositorio <em>node</em> cuyo nombre contenga <code>term</code>.
                    </li>
                    <li>
                        <code>npm update <em>nombre_paquete</em></code><br>
                        Actualiza un paquete a la útima versión disponible.
                    </li>
                    <li>
                        <code>npm dedupe</code><br>
                        Reorganiza la carpeta <code>node_modules</code> para evitar duplicidades.
                    </li>
                    <li>
                        <code>npm publish</code><br>
                        Sube el proyecto actual al <em>npm registy</em>.
                    </li>
                </ul>
            </section>
            
            <section>
                <h4>Ejemplo: listar árbol de dependencias</h4>
                <pre><code data-trim data-noescape class="no-highlight">
# <span class="hl">npm ls</span>
mimodulo@1.0.0
├─┬ express@4.14.0
│ ├─┬ accepts@1.3.3
│ │ ├─┬ mime-types@2.1.12
│ │ │ └── mime-db@1.24.0
│ │ └── negotiator@0.6.1
│ ├── array-flatten@1.1.1
│ ├── content-disposition@0.5.1
│ ├── content-type@1.0.2
│ ├── cookie@0.3.1
│ ├── cookie-signature@1.0.6
│ ├─┬ debug@2.2.0
│ │ └── ms@0.7.1
│ ├── depd@1.1.0
│ ├── encodeurl@1.0.1
│ ├── escape-html@1.0.3
│ ...
└── underscore@1.8.3
                </code></pre>
            </section>
            
            <section>
                <h3>Números de versión</h3>
                <p>Los paquetes y programas escritos en <em>Node</em> utilizan el convenio <em>semantic versioning</em> para numerar las versiones.</p>
                <p>Más información: <a href="http://semver.org/">http://semver.org/</a></p>
                <p>Una versión se identifica mediante tres números:</p>
                <img src="images/04/Versiones.svg" style="width:80%;border:none;box-shadow:none">
            </section>
            
            <section>
                <img src="images/04/Versiones.svg" style="width:3en cualquier 0%;border:none;box-shadow:none">
                <p>Al liberar una nueva versión:</p>
                <ul>
                    <li><strong>MAJOR</strong>: Se aumenta si los cambios introducidos rompen la compatibilidad con versiones anteriores.</li>
                    <li><strong>MINOR</strong>: Se aumenta si los cambios introducidos no rompen la compatibilidad con versiones anteriores, pero añaden nueva funcionalidad.</li>
                    <li><strong>PATCH</strong>: Se aumenta si no hay funcionalidad nueva, pero sí correcciones de <em>bugs</em>.</li>
                </ul>
                <p>Excepción: versiones 0.x.x, cuya API es inestable.</p>
            </section>
            
            <section>
                <h4>Rangos de versión en <code>package.json</code></h4>
                <p>¿Qué significa el símbolo <code>^</code> en el número de versión?</p>
                <pre><code data-trim data-noescape class="json">
{
  ...
  "dependencies": {
    "underscore": "<span class="hl">^</span>1.8.3",
    "express": "<span class="hl">^</span>4.14.0"
  },
  "private": true
}                
                </code></pre>
                <p>En el caso de <code>underscore</code> significa que se admite otra versión distinta de la especificada, siempre que preserve la compatibilidad de la API (es decir, versiones 1.x.x).</p>
                <p>Lo mismo se aplica a <code>express</code>.</p>
            </section>
            
            <section>
                <p>Posibles especificaciones:</p>
                <ul>
                    <li><code>1.8.3</code> La versión debe ser exactamente la especificada.</li>
                    <li><code>&gt;=1.8.3</code> Se admite cualquier versión mayor o igual.</li>
                    <li><code>&lt;=1.8.3</code> Se admite cualquier versión menor o igual.</li>
                    <li><code>~1.8.3</code> Se admiten versiones 1.8.x.</li>
                    <li><code>^1.8.3</code> Se admiten versiones 1.x.x.</li>
                    <li><code>*</code> Se admite cualquier versión.</li>
                    <li><code>1.8.3 - 2.5.1</code> Rango permitido.</li>
                </ul>
            </section>
            
            <section>
                <h2>Modelo asíncrono</h2>
                <p>Node utiliza un modelo de entradas y salidas <strong>asíncronas</strong> con el fin de permitir el desarrollo de aplicaciones altamente concurrentes.</p>
                <p>Este modelo resulta muy útil en un contexto de aplicaciones web, donde un servidor web ha de procesar miles de peticiones por segundo.</p>
            </section>
            
            <section>
                <h3>Modelos síncrono vs asíncrono</h3>
                <p>
                    Cuando ejecutamos una operación <strong>síncrona</strong>, la ejecución del programa <strong>se detiene</strong> hasta que dicha operación haya terminado.
                </p>
                <p>Ej: Lectura de fichero síncrona</p>
                <img src="images/04/Sincrona.svg" width="80%" style="border:none;box-shadow:none">
            </section>

            <section>
                <p>
                    Cuando ejecutamos una operación <strong>asíncrona</strong>, la ejecución del programa <strong>continúa</strong>, mientras la operación se realiza de manera <strong>concurrente</strong>.
                </p>
                <p>Ej: Lectura de fichero asíncrona</p>
                <img src="images/04/Asincrona.svg" width="80%" style="border:none;box-shadow:none">
            </section>
            
            <section>
                <h3>Un ejemplo: lectura de fichero</h3>
                <p>El módulo core <code>fs</code> proporciona operaciones para manejar ficheros.</p>
                <p>Dentro de este módulo hay una función para obtener el contenido de un fichero, pero esta función tiene dos variantes:</p>
                <ul>
                    <li><code>readFileSync(fichero, opcs)</code><br>
                        Lectura síncrona.</li>
                    <li><code>readFile(fichero, opcs, callback)</code><br>
                        Lectura asíncrona.</li>
                </ul>
            </section>
            
            <section>
                <h4>Lectura síncrona</h4>
                <pre><code data-trim class="javascript">
"use strict";

var fs = require("fs");

try {
    var contenido = fs.readFileSync("FichTexto.txt", 
                                    { encoding: "utf-8" });
    console.log("Fichero leído correctamente:");
    console.log(contenido);
} catch (err) {
    console.log("Se ha producido un error:");
    console.log(err.message);
}
                </code></pre>
            </section>
            
            <section>
                    <p>Las operaciones de lectura síncrona:</p>
                <div style="background:#EDF; padding:20px 2px 20px 20px">
                    <ul>
                        <li>Bloquean la ejecución del programa mientras se realizan.</li>
                        <li><strong>Devuelven</strong> el resultado de la operación.</li>
                        <li>En caso de error, lanzan <strong>excepciones</strong>.</li>
                    </ul>
                </div>
            </section>
            
            <section>
                <h4>Lectura asíncrona</h4>
                <img src="images/04/Asincrona.svg" width="80%" style="border:none;box-shadow:none">
                <p>Si la operación de lectura asíncrona se realiza de manera ajena al hilo de ejecución principal del programa, ¿cómo sabemos cuándo ha finalizado?
                </p>
                <p>Mediante el uso de funciones <strong>callback</strong>.</p>
            </section>
            
            <section>
                <h4>Funciones callback</h4>
                <p>Una función <strong>callback</strong> es una función definida por el programador, pero que no está pensada para ser llamada directamente por este, sino por otro componente del sistema.</p>
            </section>
            
            <section>
                <h4>Funciones callback: <code>readFile</code></h4>
                <p>La función <code>readFile</code>, además de recibir el nombre del fichero y las opciones de lectura, recibe un tercer parámetro, que es una función.</p>
                <p>Esta función será definida por el programador.</p>
                <p>Sin embargo, será llamada por <code>readFile</code>.</p>
                <p>Es, por tanto, una función callback.</p>
            </section>
            
            <section>
                <p>La función callback recibe dos parámetros:</p>
                <ul>
                    <li>Un objeto de la clase <code>Error</code>, en el caso en que la lectura haya fallado.<br>
                        <span style="font-size:70%">Si no ha fallado, toma el valor <code>null</code>.</span>
                    </li>
                    <li>El contenido del fichero leído, en el caso en que se haya leído correctamente.<br>
                        <span style="font-size:70%">Si ha fallado, toma el valor <code>undefined</code>.</span></li>
                </ul>
            </section>
            
            <section>
                <pre><code data-trim data-noescape class="javascript">
"use strict";

var fs = require("fs");

fs.readFile("FichTexto.txt", { encoding:"utf-8" }, <span class="hl">ficheroLeido</span>);

// Función callback
function <span class="hl">ficheroLeido</span>(err, contenido) {
    if (err) {
        console.log("Se ha producido un error:");
        console.log(err.message);
    } else {
        console.log("Fichero leído correctamente:");
        console.log(contenido);
    }
}
                </code></pre>
                <p>Tras la lectura, <code>readFile</code> llamará a la función <code>ficheroLeido</code>.</p>
            </section>
            
            <section>
                <p>Las funciones callback suelen definirse directamente como funciones anónimas en la llamada a <code>readFile</code>.</p>
                <pre><code data-trim class="javascript">
"use strict";

var fs = require("fs");

fs.readFile("FichTexto.txt", 
            { encoding: "utf-8" },
            function(err, contenido) {
                if (err) {
                    console.log("Se ha producido un error:");
                    console.log(err.message);
                } else {
                    console.log("Fichero leído correctamente:");
                    console.log(contenido);
                }        
            }
);                
                </code></pre>    
            </section>

            <section>
                    <p>Las operaciones de lectura síncrona:</p>
                <div style="background:#EDF; padding:20px 2px 20px 20px">
                    <ul>
                        <li><strong>No bloquean</strong> la ejecución del programa.<br>
                            <span style="font-size:60%">Porque se ejecutan de manera concurrente.</span>
                        </li>
                        <li><strong>No devuelven</strong> el resultado de la operación.<br>
                            <span style="font-size:60%">El resultado de la lectura se pasa como parámetro a la función <em>callback</em>.</span>
                        </li>
                        <li><strong>No</strong> lanzan <strong>excepciones</strong>.<br>
                            <span style="font-size:60%">En caso de error, es la función <em>callback</em> quien recibe la excepción como primer parámetro.</li>
                    </ul>
                </div>
            </section>
            
            <section>
                <h3>Error frecuente</h3>
                <p>¡Cuidado con el siguiente código!</p>
                <pre><code data-trim class="javascript">
var contenidoFichero;

fs.readFile("FichTexto.txt", 
            { encoding: "utf-8" },
            function(err, contenido) {
                if (!err) {
                    // Asignamos el contenido a la variable
                    // externa
                    contenidoFichero = contenido;
                }        
            });

console.log(contenidoFichero); // ¿Qué se imprime aquí?               
                </code></pre>
            </section>
            
            <section>
                <p>En el mejor de los casos, la última línea se ejecutaría después de que la lectura haya finalizado.</p>
                <img src="images/04/AsincronaBien.svg" style="width:80%; border:none">
            </section>

            <section>
                <p>Pero también podría ejecutarse antes de que la lectura termine:</p>
                <img src="images/04/AsincronaMal.svg" style="width:75%; border:none">
                <p>En este caso se imprimiría <code>undefined</code>, ya que <code>contenidoFichero</code> no habría sido inicializada en el momento de ejecutar <code>console.log</code>.</p>
            </section>
            
            <section>
                <p>Si un fragmento del programa depende del resultado de una llamada asíncrona, no debe ir tras dicha llamada:</p>
                <pre><code data-trim data-noescape class="javascript">
fs.readFile("fich.txt", function(err, contenido) {
    ...
});
<span class="hl" style="background-color:#FBB">// hacer algo con el contenido</span>
                </code></pre>
                Debe ir dentro de la función callback:
                <pre><code data-trim data-noescape class="javascript">
fs.readFile("fich.txt", function(err, contenido) {
    <span class="hl" style="background-color:#BFB">// hacer algo con el contenido</span>
    ...
});

                </code></pre>
            </section>
            
            <section>
                <h3>¿Por qué un modelo asíncrono?</h3>
                <p>Node está pensado para aplicaciones con una alta capacidad de respuesta como, por ejemplo, servidores web.</p>
                <p>La funcionalidad de la mayoría de aplicaciones web está basada en accesos a disco, u otra fuente de datos (p.ej. bases de datos), operaciones <strong>relativamente lentas</strong>.</p>
                <p>Para que un servidor web pueda atender a varios clientes, ha de gestionar adecuadamente estas operaciones de entrada y salida.</p>
            </section>
            
            <section>
                <h4>Modelos de servidores web</h4>
                <ol>
                    <li>Modelo tradicional: un proceso por petición.</li>
                    <li>Modelo tradicional: pool de hebras de ejecución.</li>
                    <li>NGINX Process Model (Node).</li>
                </ol>
            </section>
            
            <section>
                <h4>Un proceso por petición</h4>
                <img src="images/04/ServidorProcesos.svg" width="80%" style="border:none;box-shadow:none">
            </section>
            
            <section>
                <p>Se crea un proceso del sistema operativo por cada petición que se realice.</p>
                <p><strong>Inconveniente:</strong> coste de la creación de procesos.</p>
            </section>

            <section>
                <h4>Pool de hebras de ejecución</h4>
                <img src="images/04/ServidorHilos.svg" width="80%" style="border:none;box-shadow:none">
            </section>
            
            <section>
                <p>Al arrancar el servidor se crea un conjunto de hebras, inicialmente sin tarea asignada.</p>
                <p>Cuando llega una petición al servidor, una de las hebras se encarga de atenderla.</p>
                <p>Con esto nos ahorramos el coste de creación y liberación de hebras a medida que van llegando peticiones.</p>
                <p><strong>Inconveniente:</strong> el cambio del contexto de ejecución entre hebras conlleva un coste.</p>
            </section>
            
            <section>
                <h4>Modelo NGINX / Node</h4>
                <img src="images/04/ServidorNGINX.svg" width="90%" style="border:none;box-shadow:none">
            </section>
            
            <section>
                <p>Existe <strong>un único hilo</strong> en ejecución</p>
                <p>Este hilo se encarga de atender a todas las peticiones.</p>
        
                <p>Cuando se requiere realizar una operación con coste elevado en tiempo (acceso a disco, BD, red, etc.), se realiza en una &laquo;hebra&raquo; distinta.</p>
                
                <p><strong>Estas hebras son gestionadas por Node</strong>, no por el SO.</p>
                
                <p>&rArr; El cambio de contexto entre hebras es menos costoso.</p>
            </section>
            
            <section>
                <h4>Bucle principal de un servidor Node</h4>
                <pre><code data-trim class="javascript">
while (!terminado) {
    1. Esperar petición de un cliente.
    2. Procesar petición.
}                
                </code></pre>
                <p>¿Cómo se procesa la petición?</p>
            </section>
            
            <section>
                <p>Si sólo se utilizan operaciones síncronas, el servidor no acepta otra petición hasta que la hayan terminado dichas operaciones:</p>
                <pre><code data-trim class="javascript">
while (!terminado) {
    1. Esperar petición de un cliente.
    2. Procesar petición:
        2.1 var resultado = consultarBDSync(...);
        2.2 Procesar resultado
        2.3 Devolver resultado al cliente.
}                
                </code></pre>
            </section>
            
            <section>
                <p>Por el contrario, si se realizan operaciones asíncronas, será la función callback (que se ejecuta concurrentemente) la que procesa y devuelve el resultado de la operación.</p>
                <pre><code data-trim class="javascript">
while (!terminado) {
    1. Esperar petición de un cliente.
    2. Procesar petición:
        2.1 var resultado = consultarBDASync(..., callback);
}                

function callback(resultado) {
    1. Procesar resultado
    2. Devolver resultado al servidor
}
                </code></pre>
            <p>Nada más lanzar la operación <code>consultarDBAsync</code>, el servidor está listo para atender otra petición.</p>
            </section>
            
            <section>
                <h4>Consecuencias de este modelo</h4>
                <p>En el contexto de un servidor web con Node, todas las operaciones de E/S deben ser <strong>asíncronas</strong>, para evitar cuellos de botella en el procesamiento de las peticiones.</p>
                
                <p>Esto también se aplica cuando se realicen operaciones que utilicen la CPU intensivamente.</p>
                <pre><code data-trim data-noescape class="javascript">
while (!terminado) {
    1. Esperar petición de un cliente.
    2. Procesar petición (alto coste CPU). <span class="arrow_box_left caja_codigo fragment">Cuello de botella</span>
    3. Devolver respuesta.
}                         
                </code></pre>
            </section>
            
            <section>
                <div style="background-color:#ffdddd;padding:10px;">
                    La eficiencia de un servidor implementado en Node &laquo;flojea&raquo; cuando éste tiene que realizar operaciones que requieren <strong>un uso intenso de la CPU</strong>.
                </div>
                
                <p>
                    Si se desea realizar una operación de este tipo, el cómputo complejo deberá dividirse en cómputos más sencillos, y ejecutar cada uno de ellos en una iteración del bucle de node, de manera que se intercalen con el procesamiento de las demás peticiones al servidor.
                </p>
                <p>
                    Esto se puede realizar con la función <code>process.nextTick()</code><br>
                    <a href="https://howtonode.org/understanding-process-next-tick">Más información</a>
                </p>
            </section>
            
            <section>
                <h2>Módulos y paquetes Node</h2>
                <ul>
                    <li>Variables y funciones predefinidas</li>
                    <li>Módulos core:
                        <ul>
                            <li>Nombres de ficheros: <code>path</code></li>
                            <li>Manejo de ficheros: <code>fs</code></li>
                            <li>Eventos</li>
                            <li>Streams</li>
                            <li>Sistema operativo: <code>os</code></li>
                            <li>Utilidades varias: <code>util</code></li>
                        </ul>
                    </li>
                    <li>
                        Otras librerías: <code>underscore</code>, <code>moment</code>.
                    </li>
                </ul>
            </section>
            
            
            <section>
                <h3>Variables predefinidas</h3>
                <p>Las siguientes variables son accesibles desde cualquier módulo o script, pero no desde la <em>shell</em> de Node:</p>
                <ul>
                    <li><code>__filename</code>: Fichero .js que se está ejecutando (incl. directorio).</li>
                    <li><code>__dirname</code>: Directorio en el que se encuentra el fichero que se está ejecutando.</li>
                </ul>
                
                <pre><code data-trim class="javascript">
// globals.js
// ----------

console.log(__dirname);
    // &rarr; /home/manuel/AW/core-modules/

console.log(__filename);
    // &rarr; /home/manuel/AW/core-modules/globals.js
                </code></pre>
                
            </section>
            
            <section>
                <h4>La variable <code>process</code></h4>
                <p>Atributos relacionados con la ejecución del programa:</p>
                <ul>
                    <li><code>process.exit(code)</code><br>
                    Finaliza la ejecución del programa.</li>
                    <li><code>process.argv</code><br>
                        Array con los argumentos de la línea de comandos.
                    </li>
                    <li><code>process.cwd()</code> / <code>process.chdir(dir)</code><br>
                        Obtiene o cambia el directorio actual.
                    </li>
                    <li>
                        <code>process.platform</code>, <code>process.version</code>, <code>process.arch</code>
                        Información sobre el sistema operativo, versión de Node, etc.
                    </li>
                </ul>
                <a href="https://nodejs.org/docs/v4.6.1/api/process.html">https://nodejs.org/docs/v4.6.1/api/process.html</a>
            </section>
            
            
            <section>
                <h4>Ejemplo</h4>
                <pre><code data-trim class="javascript">

// Los dos primeros elementos de process.argv son el
// nombre del ejecutable de Node, y el nombre del script
var args = process.argv;

var suma;
if (args.length === 4) {
    suma = Number(args[2]) + Number(args[3]);
} else {
    suma = "No definida";
}

console.log(`Suma: ${suma}`);

console.log(`Sistema operativo: ${process.platform}`);
console.log(`Versión de node: ${process.version}`);
console.log(`Arquitectura: ${process.arch}`);                
                </code></pre>
                <pre><code data-trim data-noescape class="no-highlight">
# <span class="hl">node process.js 5 6</span>
Suma: 11
Sistema operativo: linux
Versión de node: v4.6.1
Arquitectura: x64
                </code></pre>
            </section>
            
            <section>
                <p><code>setTimeout(fun, time)</code></p>
                <p>Ejecuta la función <code>fun</code> transcurrida una cantidad de milisegundos dada.</p>
                <p>La función se ejecuta <strong>asíncronamente</strong>.</p>
                <pre><code data-trim class="javascript">

setTimeout(function() {
    console.log("Han pasado 5 segundos");
}, 5000);

console.log("Esto se ejecuta antes");
                </code></pre>
                <pre><code data-trim class="no-highlight">
Esto se ejecuta antes
Han pasado 5 segundos                
                </code></pre>
            </section>
            
            <section>
                <p>Similarmente: <code>setInterval</code>, <code>clearInterval</code>, que
                ejecutan la función dada periódicamente.</p>
                <pre><code data-trim class="javascript">
var contador = 1;

// El objeto devuelto por setInterval nos sirve
// para detener el temporizador cuando el contador llegue a 5
var interval = setInterval(function() {
    console.log(`Ejecutándose por ${contador}ª vez`);
    if (contador === 5) {
        clearInterval(interval);
    }
    contador++;
}, 1000);                
                </code></pre>
                <p>Más información <a href="https://nodejs.org/docs/v4.6.1/api/timers.html">https://nodejs.org/docs/v4.6.1/api/timers.html</a>
                </p>
            </section>
            
            <section>
                <h3>Módulo <code>path</code></h3>
                <p>Contiene funciones de utilidad para trabajar con nombres de ficheros de manera independiente del SO.</p>
                <p>Funciones más importantes:</p>
                <ul>
                    <li><code>path.parse(filename)</code><br>
                        Obtiene las distintas componentes (path, fichero, extensión, etc.)
                    </li>
                    <li><code>path.join(dir1, dir2, ...)</code>
                        Concatena varios directorios utilizando el separador del sistema operativo: <code>/</code> en sistemas UNIX (Linux), <code>\</code> en Windows.
                    </li>
                </ul>
            </section>
            
            <section>
                <pre><code data-trim class="javascript">
var path = require("path");

var infoFichero = path.parse(__filename);

console.log(infoFichero);
// &rarr; { root: '/',
//     dir: '/home/manuel/AW/core-modules',
//     base: 'paths.js',
//     ext: '.js',
//     name: 'paths' }

var nuevoFichero = path.join(infoFichero.dir, "nuevo",
                             infoFichero.base);
console.log(nuevoFichero);
// &rarr; /home/manuel/AW/core-modules/nuevo/paths.js
                </code></pre>
                <p>Más información: <a href="https://nodejs.org/docs/v4.6.1/api/path.html">https://nodejs.org/docs/v4.6.1/api/path.html</a></p>
            </section>
            
            <section>
                <h3>Módulo <code>fs</code></h3>
                <p>Funciones relacionadas con el sistema de ficheros.</p>
                <ul>
                    <li>
                        <code>readFile(fichero, options, callback)</code><br>
                        Lectura asíncrona de un fichero.
                        <p style="font-size:70%">La función callback recibe como primer parámetro un objeto <code>Error</code> (si se produce error) y como segundo parámetro el contenido del fichero.</p>
                    </li>
                    <li>
                        <code>writeFile(fichero, datos, options, callback)</code><br>
                        Escritura asíncrona de un fichero.<br>
                        <span style="font-size:70%">La función callback recibe como primer parámetro un objeto <code>Error</code> (si se produce error).</span>
                        
                    </li>
                </ul>
            </section>
            
            <section>
                <pre><code data-trim class="javascript">
var fs = require("fs");

var texto = "Nadi puede ser dichoso,\n" +
            "señora, ni desdichado,\n" +
            "sino que os haya mirado";

fs.writeFile("Poema.txt", texto, {encoding: "utf-8"}, 
    function(err) {
        if (err) {
            console.log("Error al escribir el fichero.");
        } else {
            console.log("Fichero escrito correctamente.");
            fs.readFile("Poema.txt", {encoding: "utf-8"},
                function(err, contenido)  {
                    if (!err) {
                        console.log(contenido);
                    }
                });
        }
    });                
                </code></pre>
            </section>
            
            <section>
                <p>Si no se indica la opción <code>encoding</code>, estas funciones trabajan con objetos de tipo <code>Buffer</code>, en lugar de cadenas. Un buffer representa una secuencia de bytes.</p>
                <p>Esto sirve para trabajar con ficheros binarios.</p>
                <pre><code data-trim class="javascript">
var fs = require("fs");

fs.readFile("thymeleaf.pdf", function(err, buffer) {
    // Obtenemos los cuatro primeros bytes
    var mark = buffer.slice(0, 4);
    
    // Y los imprimimos con la codificación ASCII
    console.log(mark.toString("ascii"));
});                
                </code></pre>
            </section>
            
            <section>
                <h4>Otras funciones de <code>fs</code></h4>
                <ul>
                    <li>Leer y escribir de manera segmentada: <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>.</li>
                    <li>
                        Manejo del sistema de ficheros: <code>mkdir</code>, <code>fstat</code>, <code>rename</code>, <code>unlink</code>, etc.
                    </li>
                </ul>
            </section>
            
            <section>
                <h4>Variantes síncronas</h4>
                <p>Son bloqueantes y (posiblemente) devuelven un resultado, en lugar de utilizar funciones callback.<code></code></p>
                <ul>
                    <li><code>readFileSync</code>, <code>writeFileSync</code></li>
                    <li><code>openSync</code>, <code>closeSync</code>, <code>readSync</code>, <code>writeSync</code>.</li>
                    <li><code>mkdirSync</code>, <code>fstatSync</code>, <code>renameSync</code>, etc.</li>
                </ul>
                <div style="background-color:#FBB; margin-top:1em">
                    Prohibido utilizarlas en esta asignatura
                </div>
            </section>
            
            <section>
                <h3>Módulo <code>os</code></h3>
                <p>Contiene utilidades relacionadas con el sistema operativo. Entre ellas:</p>
                <ul>
                    <li><code>homedir()</code><br>
                        Devuelve el path del directorio de usuario.
                    </li>
                    <li><code>tmpdir()</code><br>
                        Devuelve el path de un directorio para crear ficheros temporales.
                    </li>
                </ul>
                <pre><code data-trim class="javascript">
var os = require("os");

console.log(os.homedir());  // &rarr; /home/manuel
console.log(os.tmpdir());   // &rarr; /tmp
                </code></pre>
            </section>
            
        
        </div>

    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            history: true,

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [{
                src: 'plugin/markdown/marked.js'
            }, {
                src: 'plugin/markdown/markdown.js'
            }, {
                src: 'plugin/notes/notes.js',
                async: true
            }, {
                src: 'plugin/highlight/highlight.js',
                async: true,
                callback: function() {
                    hljs.initHighlightingOnLoad();
                }
            }]
        });
    </script>
</body>

</html>
